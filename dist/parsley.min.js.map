{"version":3,"sources":["parsley.min.js","/source/parsley.js","/source/src/parsley/pubsub.js","/source/src/vendor/inputevent.js","/source/src/parsley/utils.js","/source/src/parsley/defaults.js","/source/src/parsley/abstract.js","/source/src/parsley/validator.js","/source/src/parsley/validator_registry.js","/source/src/parsley/ui.js","/source/src/parsley/form.js","/source/src/parsley/factory/constraint.js","/source/src/parsley/field.js","/source/src/parsley/multiple.js","/source/src/parsley/factory.js","/source/src/parsley/main.js","/source/src/parsley/remote.js","/source/src/i18n/en.js","/source/src/parsley.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_slice","prototype","slice","global","factory","exports","module","require","define","amd","parsley","jQuery","undefined","$","adapt","fn","context","parsleyAdaptedCallback","args","call","arguments","unshift","this","apply","o","eventName","name","lastIndexOf","eventPrefix","substr","InputEvent","_this14","globals","window","extend","isNativeEvent","evt","originalEvent","isTrusted","fakeInputEvent","target","trigger","misbehaves","behavesOk","document","on","data","selector","off","install","inputEventPatched","_arr","_i","uninstall","globalID","pastWarnings","ParsleyUtils__ParsleyUtils","attr","$element","namespace","obj","attribute","attributes","regex","RegExp","hasOwnProperty","specified","test","camelize","deserializeValue","value","checkAttr","_checkAttr","is","setAttr","setAttribute","dasherize","String","generateID","num","isNaN","Number","parseJSON","e","str","replace","match","chr","toUpperCase","toLowerCase","warn","_window$console","console","warnOnce","msg","_resetWarnings","trimString","string","namespaceEvents","events","split","map","join","difference","array","remove","result","each","_","elem","indexOf","push","all","promises","when","concat","objectCreate","Object","create","Error","TypeError","_SubmitSelector","ParsleyUtils__default","ParsleyDefaults","inputs","excluded","priorityEnabled","multiple","group","uiEnabled","validationThreshold","focus","triggerAfterFailure","errorClass","successClass","classHandler","ParsleyField","errorsContainer","errorsWrapper","errorTemplate","ParsleyAbstract","__id__","asyncSupport","_pipeAccordingToValidationResult","_this","pipe","r","Deferred","validationResult","reject","resolve","promise","actualizeOptions","options","domOptions","parent","_resetOptions","initOptions","_listeners","queue","subscribe","listenTo","splice","unsubscribe","unsubscribeTo","extraArg","reset","__class__","_resetUI","_trigger","fields","destroy","_destroyUI","removeData","asyncIsValid","force","whenValid","_findRelated","find","requirementConverters","_string","integer","parseInt","number","parseFloat","reference","boolean","object","regexp","_regexp","flags","convertArrayRequirement","m","values","convertRequirement","requirementType","converter","convertExtraOptionRequirement","requirementSpec","extraOptionReader","main","extra","key","ParsleyValidator","spec","validate","requirementFirstArg","validateMultiple","validateNumber","validateString","parseRequirements","requirements","type","isPlainObject","priority","ParsleyValidatorRegistry","validators","catalog","locale","init","typeRegexes","email","digits","alphanum","url","range","decimalPlaces","Math","max","addValidator","Parsley","setLocale","addCatalog","messages","set","addMessage","message","addMessages","nameMessageObject","arg1","arg2","_setValidator","updateValidator","removeValidator","validator","getErrorMessage","constraint","typeMessages","formatMessage","defaultMessage","en","parameters","notblank","required","_ref","_ref$step","step","_ref$base","base","nb","decimals","toInt","f","round","pow","","pattern","minlength","requirement","maxlength","min","mincheck","maxcheck","check","equalto","refOrValue","$reference","val","ParsleyUI","diffResults","newResult","oldResult","deep","added","kept","found","j","assert","removed","Form","_actualizeTriggers","_this2","onSubmitValidate","onSubmitButton","_focusedField","field","noFocus","Field","_reflowUI","_buildUI","_ui","diff","lastValidationResult","_manageStatusClass","_manageErrorsMessages","_failedOnce","getErrorsMessages","errorMessage","_getErrorMessage","addError","_ref2","_ref2$updateClass","updateClass","_addError","_errorClass","updateError","_ref3","_ref3$updateClass","_updateError","removeError","_ref4","_ref4$updateClass","_removeError","hasConstraints","needsValidation","_successClass","_resetClass","errorsMessagesDisabled","_insertErrorWrapper","$errorsWrapper","append","addClass","html","removeClass","_ref5","_ref6","customConstraintErrorMessage","$errorClassHandler","_manageClassHandler","errorsWrapperId","validationInformationVisible","$handler","_inputHolder","$errorsContainer","after","_this3","$toBind","_validateIfNeeded","event","_this4","getValue","debounce","clearTimeout","_debounced","setTimeout","children","ParsleyForm","element","ParsleyForm__statusMapping","pending","resolved","rejected","_this5","$submitSource","_$submitSource","first","prop","whenValidate","state","stopImmediatePropagation","preventDefault","done","_submit","currentTarget","$synthetic","appendTo","Event","_arguments","_ParsleyUtils__default$all$done$fail$always","_this6","_ref7","submitEvent","_refreshFields","_withoutReactualizingFormOptions","fail","always","isValid","_arguments2","_this7","_ref8","_bindFields","_this8","oldFields","fieldsMappedById","not","fieldInstance","Factory","oldActualizeOptions","ConstraintFactory","parsleyField","isDomConstraint","validatorSpec","_validatorRegistry","_parseRequirements","capitalize","cap","instance","_validator","requirementList","_this9","parsleyFormInstance","constraints","constraintsByName","_bindConstraints","parsley_field__statusMapping","_whenValid$always$done$fail$always","_this10","_ref9","refreshConstraints","_isInGroup","_refreshed","_isRequired","validateIfEmpty","inArray","_arguments3","_this11","_ref10","_ref10$force","groupedConstraints","_getGroupedConstraints","_validateConstraint","_this12","_handleWhitespace","addConstraint","removeConstraint","updateConstraint","_bindHtml5Constraints","trimValue","whitespace","index","p","sort","a","b","parsley_field","ParsleyMultiple","addElement","$elements","fieldConstraints","has","filter","_init","ParsleyFactory","savedparsleyFormInstance","__version__","bind","isMultiple","handleMultiple","parsleyMultipleInstance","_this13","input","$previouslyRelated","get","doNotStore","parsleyInstance","ParsleyExtend","vernums","jquery","forEach","version","psly","instances","ParsleyConfig","ParsleyUtils","registry","i18n","method","proxy","_window$Parsley","UI","doNotUpdateClass","autoBind","deprecated","listen","callback","unsubscribeAll","emit","_instance","instanceGiven","asyncValidators","default","xhr","status","reverse","addAsyncValidator","ajaxOptions","csr","encodeURIComponent","remoteOptions","param","_remoteCache","ajax","handleXhr","then","inputevent"],"mappings":"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","file":"parsley.min.js","sourcesContent":["/*!\n* Parsley.js\n* Version 2.6.1 - built Tue, Jan 3rd 2017, 1:32 pm\n* http://parsleyjs.org\n* Guillaume Potier - <guillaume@wisembly.com>\n* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>\n* MIT Licensed\n*/\n\n// The source code below is generated by babel as\n// Parsley is written in ECMAScript 6\n//\n'use strict';\n\nvar _slice = Array.prototype.slice;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) : typeof define === 'function' && define.amd ? define(['jquery'], factory) : global.parsley = factory(global.jQuery);\n})(undefined, function ($) {\n  'use strict';\n\n  var globalID = 1;\n  var pastWarnings = {};\n\n  var ParsleyUtils__ParsleyUtils = {\n    // Parsley DOM-API\n    // returns object from dom attributes and values\n    attr: function attr($element, namespace, obj) {\n      var i;\n      var attribute;\n      var attributes;\n      var regex = new RegExp('^' + namespace, 'i');\n\n      if ('undefined' === typeof obj) obj = {};else {\n        // Clear all own properties. This won't affect prototype's values\n        for (i in obj) {\n          if (obj.hasOwnProperty(i)) delete obj[i];\n        }\n      }\n\n      if ('undefined' === typeof $element || 'undefined' === typeof $element[0]) return obj;\n\n      attributes = $element[0].attributes;\n      for (i = attributes.length; i--;) {\n        attribute = attributes[i];\n\n        if (attribute && attribute.specified && regex.test(attribute.name)) {\n          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n        }\n      }\n\n      return obj;\n    },\n\n    checkAttr: function checkAttr($element, namespace, _checkAttr) {\n      return $element.is('[' + namespace + _checkAttr + ']');\n    },\n\n    setAttr: function setAttr($element, namespace, attr, value) {\n      $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n    },\n\n    generateID: function generateID() {\n      return '' + globalID++;\n    },\n\n    /** Third party functions **/\n    // Zepto deserialize function\n    deserializeValue: function deserializeValue(value) {\n      var num;\n\n      try {\n        return value ? value == \"true\" || (value == \"false\" ? false : value == \"null\" ? null : !isNaN(num = Number(value)) ? num : /^[\\[\\{]/.test(value) ? $.parseJSON(value) : value) : value;\n      } catch (e) {\n        return value;\n      }\n    },\n\n    // Zepto camelize function\n    camelize: function camelize(str) {\n      return str.replace(/-+(.)?/g, function (match, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n    },\n\n    // Zepto dasherize function\n    dasherize: function dasherize(str) {\n      return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();\n    },\n\n    warn: function warn() {\n      var _window$console;\n\n      if (window.console && 'function' === typeof window.console.warn) (_window$console = window.console).warn.apply(_window$console, arguments);\n    },\n\n    warnOnce: function warnOnce(msg) {\n      if (!pastWarnings[msg]) {\n        pastWarnings[msg] = true;\n        this.warn.apply(this, arguments);\n      }\n    },\n\n    _resetWarnings: function _resetWarnings() {\n      pastWarnings = {};\n    },\n\n    trimString: function trimString(string) {\n      return string.replace(/^\\s+|\\s+$/g, '');\n    },\n\n    namespaceEvents: function namespaceEvents(events, namespace) {\n      events = this.trimString(events || '').split(/\\s+/);\n      if (!events[0]) return '';\n      return $.map(events, function (evt) {\n        return evt + '.' + namespace;\n      }).join(' ');\n    },\n\n    difference: function difference(array, remove) {\n      // This is O(N^2), should be optimized\n      var result = [];\n      $.each(array, function (_, elem) {\n        if (remove.indexOf(elem) == -1) result.push(elem);\n      });\n      return result;\n    },\n\n    // Alter-ego to native Promise.all, but for jQuery\n    all: function all(promises) {\n      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\n      return $.when.apply($, _toConsumableArray(promises).concat([42, 42]));\n    },\n\n    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n    objectCreate: Object.create || (function () {\n      var Object = function Object() {};\n      return function (prototype) {\n        if (arguments.length > 1) {\n          throw Error('Second argument not supported');\n        }\n        if (typeof prototype != 'object') {\n          throw TypeError('Argument must be an object');\n        }\n        Object.prototype = prototype;\n        var result = new Object();\n        Object.prototype = null;\n        return result;\n      };\n    })(),\n\n    _SubmitSelector: 'input[type=\"submit\"], button:submit'\n  };\n\n  var ParsleyUtils__default = ParsleyUtils__ParsleyUtils;\n\n  // All these options could be overriden and specified directly in DOM using\n  // `data-parsley-` default DOM-API\n  // eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n  // eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\n  var ParsleyDefaults = {\n    // ### General\n\n    // Default data-namespace for DOM API\n    namespace: 'data-parsley-',\n\n    // Supported inputs by default\n    inputs: 'input, textarea, select',\n\n    // Excluded inputs by default\n    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n    // Stop validating field on highest priority failing constraint\n    priorityEnabled: true,\n\n    // ### Field only\n\n    // identifier used to group together inputs (e.g. radio buttons...)\n    multiple: null,\n\n    // identifier (or array of identifiers) used to validate only a select group of inputs\n    group: null,\n\n    // ### UI\n    // Enable\\Disable error messages\n    uiEnabled: true,\n\n    // Key events threshold before validation\n    validationThreshold: 3,\n\n    // Focused field on form validation error. 'first'|'last'|'none'\n    focus: 'first',\n\n    // event(s) that will trigger validation before first failure. eg: `input`...\n    trigger: false,\n\n    // event(s) that will trigger validation after first failure.\n    triggerAfterFailure: 'input',\n\n    // Class that would be added on every failing validation Parsley field\n    errorClass: 'parsley-error',\n\n    // Same for success validation\n    successClass: 'parsley-success',\n\n    // Return the `$element` that will receive these above success or error classes\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    classHandler: function classHandler(ParsleyField) {},\n\n    // Return the `$element` where errors will be appended\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    errorsContainer: function errorsContainer(ParsleyField) {},\n\n    // ul elem that would receive errors' list\n    errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n    // li elem that would receive error message\n    errorTemplate: '<li></li>'\n  };\n\n  var ParsleyAbstract = function ParsleyAbstract() {\n    this.__id__ = ParsleyUtils__default.generateID();\n  };\n\n  ParsleyAbstract.prototype = {\n    asyncSupport: true, // Deprecated\n\n    _pipeAccordingToValidationResult: function _pipeAccordingToValidationResult() {\n      var _this = this;\n\n      var pipe = function pipe() {\n        var r = $.Deferred();\n        if (true !== _this.validationResult) r.reject();\n        return r.resolve().promise();\n      };\n      return [pipe, pipe];\n    },\n\n    actualizeOptions: function actualizeOptions() {\n      ParsleyUtils__default.attr(this.$element, this.options.namespace, this.domOptions);\n      if (this.parent && this.parent.actualizeOptions) this.parent.actualizeOptions();\n      return this;\n    },\n\n    _resetOptions: function _resetOptions(initOptions) {\n      this.domOptions = ParsleyUtils__default.objectCreate(this.parent.options);\n      this.options = ParsleyUtils__default.objectCreate(this.domOptions);\n      // Shallow copy of ownProperties of initOptions:\n      for (var i in initOptions) {\n        if (initOptions.hasOwnProperty(i)) this.options[i] = initOptions[i];\n      }\n      this.actualizeOptions();\n    },\n\n    _listeners: null,\n\n    // Register a callback for the given event name\n    // Callback is called with context as the first argument and the `this`\n    // The context is the current parsley instance, or window.Parsley if global\n    // A return value of `false` will interrupt the calls\n    on: function on(name, fn) {\n      this._listeners = this._listeners || {};\n      var queue = this._listeners[name] = this._listeners[name] || [];\n      queue.push(fn);\n\n      return this;\n    },\n\n    // Deprecated. Use `on` instead\n    subscribe: function subscribe(name, fn) {\n      $.listenTo(this, name.toLowerCase(), fn);\n    },\n\n    // Unregister a callback (or all if none is given) for the given event name\n    off: function off(name, fn) {\n      var queue = this._listeners && this._listeners[name];\n      if (queue) {\n        if (!fn) {\n          delete this._listeners[name];\n        } else {\n          for (var i = queue.length; i--;) if (queue[i] === fn) queue.splice(i, 1);\n        }\n      }\n      return this;\n    },\n\n    // Deprecated. Use `off`\n    unsubscribe: function unsubscribe(name, fn) {\n      $.unsubscribeTo(this, name.toLowerCase());\n    },\n\n    // Trigger an event of the given name\n    // A return value of `false` interrupts the callback chain\n    // Returns false if execution was interrupted\n    trigger: function trigger(name, target, extraArg) {\n      target = target || this;\n      var queue = this._listeners && this._listeners[name];\n      var result;\n      var parentResult;\n      if (queue) {\n        for (var i = queue.length; i--;) {\n          result = queue[i].call(target, target, extraArg);\n          if (result === false) return result;\n        }\n      }\n      if (this.parent) {\n        return this.parent.trigger(name, target, extraArg);\n      }\n      return true;\n    },\n\n    // Reset UI\n    reset: function reset() {\n      // Field case: just emit a reset event for UI\n      if ('ParsleyForm' !== this.__class__) {\n        this._resetUI();\n        return this._trigger('reset');\n      }\n\n      // Form case: emit a reset event for each field\n      for (var i = 0; i < this.fields.length; i++) this.fields[i].reset();\n\n      this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function destroy() {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      this._destroyUI();\n      if ('ParsleyForm' !== this.__class__) {\n        this.$element.removeData('Parsley');\n        this.$element.removeData('ParsleyFieldMultiple');\n        this._trigger('destroy');\n\n        return;\n      }\n\n      // Form case: destroy all its fields and then destroy stored instance\n      for (var i = 0; i < this.fields.length; i++) this.fields[i].destroy();\n\n      this.$element.removeData('Parsley');\n      this._trigger('destroy');\n    },\n\n    asyncIsValid: function asyncIsValid(group, force) {\n      ParsleyUtils__default.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\n      return this.whenValid({ group: group, force: force });\n    },\n\n    _findRelated: function _findRelated() {\n      return this.options.multiple ? this.parent.$element.find('[' + this.options.namespace + 'multiple=\"' + this.options.multiple + '\"]') : this.$element;\n    }\n  };\n\n  var requirementConverters = {\n    string: function string(_string) {\n      return _string;\n    },\n    integer: function integer(string) {\n      if (isNaN(string)) throw 'Requirement is not an integer: \"' + string + '\"';\n      return parseInt(string, 10);\n    },\n    number: function number(string) {\n      if (isNaN(string)) throw 'Requirement is not a number: \"' + string + '\"';\n      return parseFloat(string);\n    },\n    reference: function reference(string) {\n      // Unused for now\n      var result = $(string);\n      if (result.length === 0) throw 'No such reference: \"' + string + '\"';\n      return result;\n    },\n    boolean: function boolean(string) {\n      return string !== 'false';\n    },\n    object: function object(string) {\n      return ParsleyUtils__default.deserializeValue(string);\n    },\n    regexp: function regexp(_regexp) {\n      var flags = '';\n\n      // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n      if (/^\\/.*\\/(?:[gimy]*)$/.test(_regexp)) {\n        // Replace the regexp literal string with the first match group: ([gimy]*)\n        // If no flag is present, this will be a blank string\n        flags = _regexp.replace(/.*\\/([gimy]*)$/, '$1');\n        // Again, replace the regexp literal string with the first match group:\n        // everything excluding the opening and closing slashes and the flags\n        _regexp = _regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n      } else {\n        // Anchor regexp:\n        _regexp = '^' + _regexp + '$';\n      }\n      return new RegExp(_regexp, flags);\n    }\n  };\n\n  var convertArrayRequirement = function convertArrayRequirement(string, length) {\n    var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n    if (!m) throw 'Requirement is not an array: \"' + string + '\"';\n    var values = m[1].split(',').map(ParsleyUtils__default.trimString);\n    if (values.length !== length) throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n    return values;\n  };\n\n  var convertRequirement = function convertRequirement(requirementType, string) {\n    var converter = requirementConverters[requirementType || 'string'];\n    if (!converter) throw 'Unknown requirement specification: \"' + requirementType + '\"';\n    return converter(string);\n  };\n\n  var convertExtraOptionRequirement = function convertExtraOptionRequirement(requirementSpec, string, extraOptionReader) {\n    var main = null;\n    var extra = {};\n    for (var key in requirementSpec) {\n      if (key) {\n        var value = extraOptionReader(key);\n        if ('string' === typeof value) value = convertRequirement(requirementSpec[key], value);\n        extra[key] = value;\n      } else {\n        main = convertRequirement(requirementSpec[key], string);\n      }\n    }\n    return [main, extra];\n  };\n\n  // A Validator needs to implement the methods `validate` and `parseRequirements`\n\n  var ParsleyValidator = function ParsleyValidator(spec) {\n    $.extend(true, this, spec);\n  };\n\n  ParsleyValidator.prototype = {\n    // Returns `true` iff the given `value` is valid according the given requirements.\n    validate: function validate(value, requirementFirstArg) {\n      if (this.fn) {\n        // Legacy style validator\n\n        if (arguments.length > 3) // If more args then value, requirement, instance...\n          requirementFirstArg = [].slice.call(arguments, 1, -1); // Skip first arg (value) and last (instance), combining the rest\n        return this.fn.call(this, value, requirementFirstArg);\n      }\n\n      if ($.isArray(value)) {\n        if (!this.validateMultiple) throw 'Validator `' + this.name + '` does not handle multiple values';\n        return this.validateMultiple.apply(this, arguments);\n      } else {\n        if (this.validateNumber) {\n          if (isNaN(value)) return false;\n          arguments[0] = parseFloat(arguments[0]);\n          return this.validateNumber.apply(this, arguments);\n        }\n        if (this.validateString) {\n          return this.validateString.apply(this, arguments);\n        }\n        throw 'Validator `' + this.name + '` only handles multiple values';\n      }\n    },\n\n    // Parses `requirements` into an array of arguments,\n    // according to `this.requirementType`\n    parseRequirements: function parseRequirements(requirements, extraOptionReader) {\n      if ('string' !== typeof requirements) {\n        // Assume requirement already parsed\n        // but make sure we return an array\n        return $.isArray(requirements) ? requirements : [requirements];\n      }\n      var type = this.requirementType;\n      if ($.isArray(type)) {\n        var values = convertArrayRequirement(requirements, type.length);\n        for (var i = 0; i < values.length; i++) values[i] = convertRequirement(type[i], values[i]);\n        return values;\n      } else if ($.isPlainObject(type)) {\n        return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n      } else {\n        return [convertRequirement(type, requirements)];\n      }\n    },\n    // Defaults:\n    requirementType: 'string',\n\n    priority: 2\n\n  };\n\n  var ParsleyValidatorRegistry = function ParsleyValidatorRegistry(validators, catalog) {\n    this.__class__ = 'ParsleyValidatorRegistry';\n\n    // Default Parsley locale is en\n    this.locale = 'en';\n\n    this.init(validators || {}, catalog || {});\n  };\n\n  var typeRegexes = {\n    email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\n    number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\n\n    integer: /^-?\\d+$/,\n\n    digits: /^\\d+$/,\n\n    alphanum: /^\\w+$/i,\n\n    url: new RegExp(\"^\" +\n    // protocol identifier\n    \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n    // user:pass authentication\n    \"(?:\\\\S+(?::\\\\S*)?@)?\" + \"(?:\" +\n    // IP address exclusion\n    // private & local networks\n    // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n    // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n    // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n    // IP address dotted notation octets\n    // excludes loopback network 0.0.0.0\n    // excludes reserved space >= 224.0.0.0\n    // excludes network & broacast addresses\n    // (first & last IP address of each class)\n    \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" + \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" + \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" + \"|\" +\n    // host name\n    '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)' +\n    // domain name\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*' +\n    // TLD identifier\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))' + \")\" +\n    // port number\n    \"(?::\\\\d{2,5})?\" +\n    // resource path\n    \"(?:/\\\\S*)?\" + \"$\", 'i')\n  };\n  typeRegexes.range = typeRegexes.number;\n\n  // See http://stackoverflow.com/a/10454560/8279\n  var decimalPlaces = function decimalPlaces(num) {\n    var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) {\n      return 0;\n    }\n    return Math.max(0,\n    // Number of digits right of decimal point.\n    (match[1] ? match[1].length : 0) - (\n    // Adjust for scientific notation.\n    match[2] ? +match[2] : 0));\n  };\n\n  ParsleyValidatorRegistry.prototype = {\n    init: function init(validators, catalog) {\n      this.catalog = catalog;\n      // Copy prototype's validators:\n      this.validators = $.extend({}, this.validators);\n\n      for (var name in validators) this.addValidator(name, validators[name].fn, validators[name].priority);\n\n      window.Parsley.trigger('parsley:validator:init');\n    },\n\n    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n    setLocale: function setLocale(locale) {\n      if ('undefined' === typeof this.catalog[locale]) throw new Error(locale + ' is not available in the catalog');\n\n      this.locale = locale;\n\n      return this;\n    },\n\n    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n    addCatalog: function addCatalog(locale, messages, set) {\n      if ('object' === typeof messages) this.catalog[locale] = messages;\n\n      if (true === set) return this.setLocale(locale);\n\n      return this;\n    },\n\n    // Add a specific message for a given constraint in a given locale\n    addMessage: function addMessage(locale, name, message) {\n      if ('undefined' === typeof this.catalog[locale]) this.catalog[locale] = {};\n\n      this.catalog[locale][name] = message;\n\n      return this;\n    },\n\n    // Add messages for a given locale\n    addMessages: function addMessages(locale, nameMessageObject) {\n      for (var name in nameMessageObject) this.addMessage(locale, name, nameMessageObject[name]);\n\n      return this;\n    },\n\n    // Add a new validator\n    //\n    //    addValidator('custom', {\n    //        requirementType: ['integer', 'integer'],\n    //        validateString: function(value, from, to) {},\n    //        priority: 22,\n    //        messages: {\n    //          en: \"Hey, that's no good\",\n    //          fr: \"Aye aye, pas bon du tout\",\n    //        }\n    //    })\n    //\n    // Old API was addValidator(name, function, priority)\n    //\n    addValidator: function addValidator(name, arg1, arg2) {\n      if (this.validators[name]) ParsleyUtils__default.warn('Validator \"' + name + '\" is already defined.');else if (ParsleyDefaults.hasOwnProperty(name)) {\n        ParsleyUtils__default.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n        return;\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    updateValidator: function updateValidator(name, arg1, arg2) {\n      if (!this.validators[name]) {\n        ParsleyUtils__default.warn('Validator \"' + name + '\" is not already defined.');\n        return this.addValidator.apply(this, arguments);\n      }\n      return this._setValidator.apply(this, arguments);\n    },\n\n    removeValidator: function removeValidator(name) {\n      if (!this.validators[name]) ParsleyUtils__default.warn('Validator \"' + name + '\" is not defined.');\n\n      delete this.validators[name];\n\n      return this;\n    },\n\n    _setValidator: function _setValidator(name, validator, priority) {\n      if ('object' !== typeof validator) {\n        // Old style validator, with `fn` and `priority`\n        validator = {\n          fn: validator,\n          priority: priority\n        };\n      }\n      if (!validator.validate) {\n        validator = new ParsleyValidator(validator);\n      }\n      this.validators[name] = validator;\n\n      for (var locale in validator.messages || {}) this.addMessage(locale, name, validator.messages[locale]);\n\n      return this;\n    },\n\n    getErrorMessage: function getErrorMessage(constraint) {\n      var message;\n\n      // Type constraints are a bit different, we have to match their requirements too to find right error message\n      if ('type' === constraint.name) {\n        var typeMessages = this.catalog[this.locale][constraint.name] || {};\n        message = typeMessages[constraint.requirements];\n      } else message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n    },\n\n    // Kind of light `sprintf()` implementation\n    formatMessage: function formatMessage(string, parameters) {\n      if ('object' === typeof parameters) {\n        for (var i in parameters) string = this.formatMessage(string, parameters[i]);\n\n        return string;\n      }\n\n      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\n    },\n\n    // Here is the Parsley default validators list.\n    // A validator is an object with the following key values:\n    //  - priority: an integer\n    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n    // Alternatively, a validator can be a function that returns such an object\n    //\n    validators: {\n      notblank: {\n        validateString: function validateString(value) {\n          return (/\\S/.test(value)\n          );\n        },\n        priority: 2\n      },\n      required: {\n        validateMultiple: function validateMultiple(values) {\n          return values.length > 0;\n        },\n        validateString: function validateString(value) {\n          return (/\\S/.test(value)\n          );\n        },\n        priority: 512\n      },\n      type: {\n        validateString: function validateString(value, type) {\n          var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n          var _ref$step = _ref.step;\n          var step = _ref$step === undefined ? 'any' : _ref$step;\n          var _ref$base = _ref.base;\n          var base = _ref$base === undefined ? 0 : _ref$base;\n\n          var regex = typeRegexes[type];\n          if (!regex) {\n            throw new Error('validator type `' + type + '` is not supported');\n          }\n          if (!regex.test(value)) return false;\n          if ('number' === type) {\n            if (!/^any$/i.test(step || '')) {\n              var nb = Number(value);\n              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\n              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\n                return false;\n              // Be careful of rounding errors by using integers.\n              var toInt = function toInt(f) {\n                return Math.round(f * Math.pow(10, decimals));\n              };\n              if ((toInt(nb) - toInt(base)) % toInt(step) != 0) return false;\n            }\n          }\n          return true;\n        },\n        requirementType: {\n          '': 'string',\n          step: 'string',\n          base: 'number'\n        },\n        priority: 256\n      },\n      pattern: {\n        validateString: function validateString(value, regexp) {\n          return regexp.test(value);\n        },\n        requirementType: 'regexp',\n        priority: 64\n      },\n      minlength: {\n        validateString: function validateString(value, requirement) {\n          return value.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxlength: {\n        validateString: function validateString(value, requirement) {\n          return value.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      length: {\n        validateString: function validateString(value, min, max) {\n          return value.length >= min && value.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      mincheck: {\n        validateMultiple: function validateMultiple(values, requirement) {\n          return values.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxcheck: {\n        validateMultiple: function validateMultiple(values, requirement) {\n          return values.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      check: {\n        validateMultiple: function validateMultiple(values, min, max) {\n          return values.length >= min && values.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      min: {\n        validateNumber: function validateNumber(value, requirement) {\n          return value >= requirement;\n        },\n        requirementType: 'number',\n        priority: 30\n      },\n      max: {\n        validateNumber: function validateNumber(value, requirement) {\n          return value <= requirement;\n        },\n        requirementType: 'number',\n        priority: 30\n      },\n      range: {\n        validateNumber: function validateNumber(value, min, max) {\n          return value >= min && value <= max;\n        },\n        requirementType: ['number', 'number'],\n        priority: 30\n      },\n      equalto: {\n        validateString: function validateString(value, refOrValue) {\n          var $reference = $(refOrValue);\n          if ($reference.length) return value === $reference.val();else return value === refOrValue;\n        },\n        priority: 256\n      }\n    }\n  };\n\n  var ParsleyUI = {};\n\n  var diffResults = function diffResults(newResult, oldResult, deep) {\n    var added = [];\n    var kept = [];\n\n    for (var i = 0; i < newResult.length; i++) {\n      var found = false;\n\n      for (var j = 0; j < oldResult.length; j++) if (newResult[i].assert.name === oldResult[j].assert.name) {\n        found = true;\n        break;\n      }\n\n      if (found) kept.push(newResult[i]);else added.push(newResult[i]);\n    }\n\n    return {\n      kept: kept,\n      added: added,\n      removed: !deep ? diffResults(oldResult, newResult, true).added : []\n    };\n  };\n\n  ParsleyUI.Form = {\n\n    _actualizeTriggers: function _actualizeTriggers() {\n      var _this2 = this;\n\n      this.$element.on('submit.Parsley', function (evt) {\n        _this2.onSubmitValidate(evt);\n      });\n      this.$element.on('click.Parsley', ParsleyUtils__default._SubmitSelector, function (evt) {\n        _this2.onSubmitButton(evt);\n      });\n\n      // UI could be disabled\n      if (false === this.options.uiEnabled) return;\n\n      this.$element.attr('novalidate', '');\n    },\n\n    focus: function focus() {\n      this._focusedField = null;\n\n      if (true === this.validationResult || 'none' === this.options.focus) return null;\n\n      for (var i = 0; i < this.fields.length; i++) {\n        var field = this.fields[i];\n        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n          this._focusedField = field.$element;\n          if ('first' === this.options.focus) break;\n        }\n      }\n\n      if (null === this._focusedField) return null;\n\n      return this._focusedField.focus();\n    },\n\n    _destroyUI: function _destroyUI() {\n      // Reset all event listeners\n      this.$element.off('.Parsley');\n    }\n\n  };\n\n  ParsleyUI.Field = {\n\n    _reflowUI: function _reflowUI() {\n      this._buildUI();\n\n      // If this field doesn't have an active UI don't bother doing something\n      if (!this._ui) return;\n\n      // Diff between two validation results\n      var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\n\n      // Then store current validation result for next reflow\n      this._ui.lastValidationResult = this.validationResult;\n\n      // Handle valid / invalid / none field class\n      this._manageStatusClass();\n\n      // Add, remove, updated errors messages\n      this._manageErrorsMessages(diff);\n\n      // Triggers impl\n      this._actualizeTriggers();\n\n      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\n        this._failedOnce = true;\n        this._actualizeTriggers();\n      }\n    },\n\n    // Returns an array of field's error message(s)\n    getErrorsMessages: function getErrorsMessages() {\n      // No error message, field is valid\n      if (true === this.validationResult) return [];\n\n      var messages = [];\n\n      for (var i = 0; i < this.validationResult.length; i++) messages.push(this.validationResult[i].errorMessage || this._getErrorMessage(this.validationResult[i].assert));\n\n      return messages;\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    addError: function addError(name) {\n      var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var message = _ref2.message;\n      var assert = _ref2.assert;\n      var _ref2$updateClass = _ref2.updateClass;\n      var updateClass = _ref2$updateClass === undefined ? true : _ref2$updateClass;\n\n      this._buildUI();\n      this._addError(name, { message: message, assert: assert });\n\n      if (updateClass) this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    updateError: function updateError(name) {\n      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var message = _ref3.message;\n      var assert = _ref3.assert;\n      var _ref3$updateClass = _ref3.updateClass;\n      var updateClass = _ref3$updateClass === undefined ? true : _ref3$updateClass;\n\n      this._buildUI();\n      this._updateError(name, { message: message, assert: assert });\n\n      if (updateClass) this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    removeError: function removeError(name) {\n      var _ref4 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var _ref4$updateClass = _ref4.updateClass;\n      var updateClass = _ref4$updateClass === undefined ? true : _ref4$updateClass;\n\n      this._buildUI();\n      this._removeError(name);\n\n      // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\n      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n      if (updateClass) this._manageStatusClass();\n    },\n\n    _manageStatusClass: function _manageStatusClass() {\n      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult) this._successClass();else if (this.validationResult.length > 0) this._errorClass();else this._resetClass();\n    },\n\n    _manageErrorsMessages: function _manageErrorsMessages(diff) {\n      if ('undefined' !== typeof this.options.errorsMessagesDisabled) return;\n\n      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n      if ('undefined' !== typeof this.options.errorMessage) {\n        if (diff.added.length || diff.kept.length) {\n          this._insertErrorWrapper();\n\n          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length) this._ui.$errorsWrapper.append($(this.options.errorTemplate).addClass('parsley-custom-error-message'));\n\n          return this._ui.$errorsWrapper.addClass('filled').find('.parsley-custom-error-message').html(this.options.errorMessage);\n        }\n\n        return this._ui.$errorsWrapper.removeClass('filled').find('.parsley-custom-error-message').remove();\n      }\n\n      // Show, hide, update failing constraints messages\n      for (var i = 0; i < diff.removed.length; i++) this._removeError(diff.removed[i].assert.name);\n\n      for (i = 0; i < diff.added.length; i++) this._addError(diff.added[i].assert.name, { message: diff.added[i].errorMessage, assert: diff.added[i].assert });\n\n      for (i = 0; i < diff.kept.length; i++) this._updateError(diff.kept[i].assert.name, { message: diff.kept[i].errorMessage, assert: diff.kept[i].assert });\n    },\n\n    _addError: function _addError(name, _ref5) {\n      var message = _ref5.message;\n      var assert = _ref5.assert;\n\n      this._insertErrorWrapper();\n      this._ui.$errorsWrapper.addClass('filled').append($(this.options.errorTemplate).addClass('parsley-' + name).html(message || this._getErrorMessage(assert)));\n    },\n\n    _updateError: function _updateError(name, _ref6) {\n      var message = _ref6.message;\n      var assert = _ref6.assert;\n\n      this._ui.$errorsWrapper.addClass('filled').find('.parsley-' + name).html(message || this._getErrorMessage(assert));\n    },\n\n    _removeError: function _removeError(name) {\n      this._ui.$errorsWrapper.removeClass('filled').find('.parsley-' + name).remove();\n    },\n\n    _getErrorMessage: function _getErrorMessage(constraint) {\n      var customConstraintErrorMessage = constraint.name + 'Message';\n\n      if ('undefined' !== typeof this.options[customConstraintErrorMessage]) return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\n\n      return window.Parsley.getErrorMessage(constraint);\n    },\n\n    _buildUI: function _buildUI() {\n      // UI could be already built or disabled\n      if (this._ui || false === this.options.uiEnabled) return;\n\n      var _ui = {};\n\n      // Give field its Parsley id in DOM\n      this.$element.attr(this.options.namespace + 'id', this.__id__);\n\n      /** Generate important UI elements and store them in this **/\n      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n      _ui.$errorClassHandler = this._manageClassHandler();\n\n      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\n      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n      _ui.lastValidationResult = [];\n      _ui.validationInformationVisible = false;\n\n      // Store it in this for later\n      this._ui = _ui;\n    },\n\n    // Determine which element will have `parsley-error` and `parsley-success` classes\n    _manageClassHandler: function _manageClassHandler() {\n      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n      if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length) return $(this.options.classHandler);\n\n      // Class handled could also be determined by function given in Parsley options\n      var $handler = this.options.classHandler.call(this, this);\n\n      // If this function returned a valid existing DOM element, go for it\n      if ('undefined' !== typeof $handler && $handler.length) return $handler;\n\n      return this._inputHolder();\n    },\n\n    _inputHolder: function _inputHolder() {\n      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\n      if (!this.options.multiple || this.$element.is('select')) return this.$element;\n\n      // But if multiple element (radio, checkbox), that would be their parent\n      return this.$element.parent();\n    },\n\n    _insertErrorWrapper: function _insertErrorWrapper() {\n      var $errorsContainer;\n\n      // Nothing to do if already inserted\n      if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();\n\n      if ('string' === typeof this.options.errorsContainer) {\n        if ($(this.options.errorsContainer).length) return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);else ParsleyUtils__default.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\n      } else if ('function' === typeof this.options.errorsContainer) $errorsContainer = this.options.errorsContainer.call(this, this);\n\n      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length) return $errorsContainer.append(this._ui.$errorsWrapper);\n\n      return this._inputHolder().after(this._ui.$errorsWrapper);\n    },\n\n    _actualizeTriggers: function _actualizeTriggers() {\n      var _this3 = this;\n\n      var $toBind = this._findRelated();\n      var trigger;\n\n      // Remove Parsley events already bound on this field\n      $toBind.off('.Parsley');\n      if (this._failedOnce) $toBind.on(ParsleyUtils__default.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), function () {\n        _this3._validateIfNeeded();\n      });else if (trigger = ParsleyUtils__default.namespaceEvents(this.options.trigger, 'Parsley')) {\n        $toBind.on(trigger, function (event) {\n          _this3._validateIfNeeded(event);\n        });\n      }\n    },\n\n    _validateIfNeeded: function _validateIfNeeded(event) {\n      var _this4 = this;\n\n      // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\n      // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n      if (event && /key|input/.test(event.type)) if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold) return;\n\n      if (this.options.debounce) {\n        window.clearTimeout(this._debounced);\n        this._debounced = window.setTimeout(function () {\n          return _this4.validate();\n        }, this.options.debounce);\n      } else this.validate();\n    },\n\n    _resetUI: function _resetUI() {\n      // Reset all event listeners\n      this._failedOnce = false;\n      this._actualizeTriggers();\n\n      // Nothing to do if UI never initialized for this field\n      if ('undefined' === typeof this._ui) return;\n\n      // Reset all errors' li\n      this._ui.$errorsWrapper.removeClass('filled').children().remove();\n\n      // Reset validation class\n      this._resetClass();\n\n      // Reset validation flags and last validation result\n      this._ui.lastValidationResult = [];\n      this._ui.validationInformationVisible = false;\n    },\n\n    _destroyUI: function _destroyUI() {\n      this._resetUI();\n\n      if ('undefined' !== typeof this._ui) this._ui.$errorsWrapper.remove();\n\n      delete this._ui;\n    },\n\n    _successClass: function _successClass() {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\n    },\n    _errorClass: function _errorClass() {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\n    },\n    _resetClass: function _resetClass() {\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\n    }\n  };\n\n  var ParsleyForm = function ParsleyForm(element, domOptions, options) {\n    this.__class__ = 'ParsleyForm';\n\n    this.$element = $(element);\n    this.domOptions = domOptions;\n    this.options = options;\n    this.parent = window.Parsley;\n\n    this.fields = [];\n    this.validationResult = null;\n  };\n\n  var ParsleyForm__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  ParsleyForm.prototype = {\n    onSubmitValidate: function onSubmitValidate(event) {\n      var _this5 = this;\n\n      // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n      if (true === event.parsley) return;\n\n      // If we didn't come here through a submit button, use the first one in the form\n      var $submitSource = this._$submitSource || this.$element.find(ParsleyUtils__default._SubmitSelector).first();\n      this._$submitSource = null;\n      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\n      if ($submitSource.is('[formnovalidate]')) return;\n\n      var promise = this.whenValidate({ event: event });\n\n      if ('resolved' === promise.state() && false !== this._trigger('submit')) {\n        // All good, let event go through. We make this distinction because browsers\n        // differ in their handling of `submit` being called from inside a submit event [#1047]\n      } else {\n          // Rejected or pending: cancel this submit\n          event.stopImmediatePropagation();\n          event.preventDefault();\n          if ('pending' === promise.state()) promise.done(function () {\n            _this5._submit($submitSource);\n          });\n        }\n    },\n\n    onSubmitButton: function onSubmitButton(event) {\n      this._$submitSource = $(event.currentTarget);\n    },\n    // internal\n    // _submit submits the form, this time without going through the validations.\n    // Care must be taken to \"fake\" the actual submit button being clicked.\n    _submit: function _submit($submitSource) {\n      if (false === this._trigger('submit')) return;\n      // Add submit button's data\n      if ($submitSource) {\n        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\n        if (0 === $synthetic.length) $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\n        $synthetic.attr({\n          name: $submitSource.attr('name'),\n          value: $submitSource.attr('value')\n        });\n      }\n\n      this.$element.trigger($.extend($.Event('submit'), { parsley: true }));\n    },\n\n    // Performs validation on fields while triggering events.\n    // @returns `true` if all validations succeeds, `false`\n    // if a failure is immediately detected, or `null`\n    // if dependant on a promise.\n    // Consider using `whenValidate` instead.\n    validate: function validate(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\n\n        var _arguments = _slice.call(arguments);\n\n        var group = _arguments[0];\n        var force = _arguments[1];\n        var event = _arguments[2];\n\n        options = { group: group, force: force, event: event };\n      }\n      return ParsleyForm__statusMapping[this.whenValidate(options).state()];\n    },\n\n    whenValidate: function whenValidate() {\n      var _ParsleyUtils__default$all$done$fail$always,\n          _this6 = this;\n\n      var _ref7 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var group = _ref7.group;\n      var force = _ref7.force;\n      var event = _ref7.event;\n\n      this.submitEvent = event;\n      if (event) {\n        this.submitEvent = $.extend({}, event, { preventDefault: function preventDefault() {\n            ParsleyUtils__default.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\n            _this6.validationResult = false;\n          } });\n      }\n      this.validationResult = true;\n\n      // fire validate event to eventually modify things before every validation\n      this._trigger('validate');\n\n      // Refresh form DOM options and form's fields that could have changed\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function () {\n        return $.map(_this6.fields, function (field) {\n          return field.whenValidate({ force: force, group: group });\n        });\n      });\n\n      return (_ParsleyUtils__default$all$done$fail$always = ParsleyUtils__default.all(promises).done(function () {\n        _this6._trigger('success');\n      }).fail(function () {\n        _this6.validationResult = false;\n        _this6.focus();\n        _this6._trigger('error');\n      }).always(function () {\n        _this6._trigger('validated');\n      })).pipe.apply(_ParsleyUtils__default$all$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));\n    },\n\n    // Iterate over refreshed fields, and stop on first failure.\n    // Returns `true` if all fields are valid, `false` if a failure is detected\n    // or `null` if the result depends on an unresolved promise.\n    // Prefer using `whenValid` instead.\n    isValid: function isValid(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\n\n        var _arguments2 = _slice.call(arguments);\n\n        var group = _arguments2[0];\n        var force = _arguments2[1];\n\n        options = { group: group, force: force };\n      }\n      return ParsleyForm__statusMapping[this.whenValid(options).state()];\n    },\n\n    // Iterate over refreshed fields and validate them.\n    // Returns a promise.\n    // A validation that immediately fails will interrupt the validations.\n    whenValid: function whenValid() {\n      var _this7 = this;\n\n      var _ref8 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var group = _ref8.group;\n      var force = _ref8.force;\n\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(function () {\n        return $.map(_this7.fields, function (field) {\n          return field.whenValid({ group: group, force: force });\n        });\n      });\n      return ParsleyUtils__default.all(promises);\n    },\n\n    _refreshFields: function _refreshFields() {\n      return this.actualizeOptions()._bindFields();\n    },\n\n    _bindFields: function _bindFields() {\n      var _this8 = this;\n\n      var oldFields = this.fields;\n\n      this.fields = [];\n      this.fieldsMappedById = {};\n\n      this._withoutReactualizingFormOptions(function () {\n        _this8.$element.find(_this8.options.inputs).not(_this8.options.excluded).each(function (_, element) {\n          var fieldInstance = new window.Parsley.Factory(element, {}, _this8);\n\n          // Only add valid and not excluded `ParsleyField` and `ParsleyFieldMultiple` children\n          if (('ParsleyField' === fieldInstance.__class__ || 'ParsleyFieldMultiple' === fieldInstance.__class__) && true !== fieldInstance.options.excluded) if ('undefined' === typeof _this8.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__]) {\n            _this8.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__] = fieldInstance;\n            _this8.fields.push(fieldInstance);\n          }\n        });\n\n        $.each(ParsleyUtils__default.difference(oldFields, _this8.fields), function (_, field) {\n          field._trigger('reset');\n        });\n      });\n      return this;\n    },\n\n    // Internal only.\n    // Looping on a form's fields to do validation or similar\n    // will trigger reactualizing options on all of them, which\n    // in turn will reactualize the form's options.\n    // To avoid calling actualizeOptions so many times on the form\n    // for nothing, _withoutReactualizingFormOptions temporarily disables\n    // the method actualizeOptions on this form while `fn` is called.\n    _withoutReactualizingFormOptions: function _withoutReactualizingFormOptions(fn) {\n      var oldActualizeOptions = this.actualizeOptions;\n      this.actualizeOptions = function () {\n        return this;\n      };\n      var result = fn();\n      this.actualizeOptions = oldActualizeOptions;\n      return result;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    // Returns true iff event is not interrupted and default not prevented.\n    _trigger: function _trigger(eventName) {\n      return this.trigger('form:' + eventName);\n    }\n\n  };\n\n  var ConstraintFactory = function ConstraintFactory(parsleyField, name, requirements, priority, isDomConstraint) {\n    if (!/ParsleyField/.test(parsleyField.__class__)) throw new Error('ParsleyField or ParsleyFieldMultiple instance expected');\n\n    var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n    var validator = new ParsleyValidator(validatorSpec);\n\n    $.extend(this, {\n      validator: validator,\n      name: name,\n      requirements: requirements,\n      priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n      isDomConstraint: true === isDomConstraint\n    });\n    this._parseRequirements(parsleyField.options);\n  };\n\n  var capitalize = function capitalize(str) {\n    var cap = str[0].toUpperCase();\n    return cap + str.slice(1);\n  };\n\n  ConstraintFactory.prototype = {\n    validate: function validate(value, instance) {\n      var _validator;\n\n      return (_validator = this.validator).validate.apply(_validator, [value].concat(_toConsumableArray(this.requirementList), [instance]));\n    },\n\n    _parseRequirements: function _parseRequirements(options) {\n      var _this9 = this;\n\n      this.requirementList = this.validator.parseRequirements(this.requirements, function (key) {\n        return options[_this9.name + capitalize(key)];\n      });\n    }\n  };\n\n  var ParsleyField = function ParsleyField(field, domOptions, options, parsleyFormInstance) {\n    this.__class__ = 'ParsleyField';\n\n    this.$element = $(field);\n\n    // Set parent if we have one\n    if ('undefined' !== typeof parsleyFormInstance) {\n      this.parent = parsleyFormInstance;\n    }\n\n    this.options = options;\n    this.domOptions = domOptions;\n\n    // Initialize some properties\n    this.constraints = [];\n    this.constraintsByName = {};\n    this.validationResult = true;\n\n    // Bind constraints\n    this._bindConstraints();\n  };\n\n  var parsley_field__statusMapping = { pending: null, resolved: true, rejected: false };\n\n  ParsleyField.prototype = {\n    // # Public API\n    // Validate field and trigger some events for mainly `ParsleyUI`\n    // @returns `true`, an array of the validators that failed, or\n    // `null` if validation is not finished. Prefer using whenValidate\n    validate: function validate(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\n        options = { options: options };\n      }\n      var promise = this.whenValidate(options);\n      if (!promise) // If excluded with `group` option\n        return true;\n      switch (promise.state()) {\n        case 'pending':\n          return null;\n        case 'resolved':\n          return true;\n        case 'rejected':\n          return this.validationResult;\n      }\n    },\n\n    // Validate field and trigger some events for mainly `ParsleyUI`\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if field is not in the given `group`.\n    whenValidate: function whenValidate() {\n      var _whenValid$always$done$fail$always,\n          _this10 = this;\n\n      var _ref9 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var force = _ref9.force;\n      var group = _ref9.group;\n\n      // do not validate a field if not the same as given validation group\n      this.refreshConstraints();\n      if (group && !this._isInGroup(group)) return;\n\n      this.value = this.getValue();\n\n      // Field Validate event. `this.value` could be altered for custom needs\n      this._trigger('validate');\n\n      return (_whenValid$always$done$fail$always = this.whenValid({ force: force, value: this.value, _refreshed: true }).always(function () {\n        _this10._reflowUI();\n      }).done(function () {\n        _this10._trigger('success');\n      }).fail(function () {\n        _this10._trigger('error');\n      }).always(function () {\n        _this10._trigger('validated');\n      })).pipe.apply(_whenValid$always$done$fail$always, _toConsumableArray(this._pipeAccordingToValidationResult()));\n    },\n\n    hasConstraints: function hasConstraints() {\n      return 0 !== this.constraints.length;\n    },\n\n    // An empty optional field does not need validation\n    needsValidation: function needsValidation(value) {\n      if ('undefined' === typeof value) value = this.getValue();\n\n      // If a field is empty and not required, it is valid\n      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty) return false;\n\n      return true;\n    },\n\n    _isInGroup: function _isInGroup(group) {\n      if ($.isArray(this.options.group)) return -1 !== $.inArray(group, this.options.group);\n      return this.options.group === group;\n    },\n\n    // Just validate field. Do not trigger any event.\n    // Returns `true` iff all constraints pass, `false` if there are failures,\n    // or `null` if the result can not be determined yet (depends on a promise)\n    // See also `whenValid`.\n    isValid: function isValid(options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\n\n        var _arguments3 = _slice.call(arguments);\n\n        var force = _arguments3[0];\n        var value = _arguments3[1];\n\n        options = { force: force, value: value };\n      }\n      var promise = this.whenValid(options);\n      if (!promise) // Excluded via `group`\n        return true;\n      return parsley_field__statusMapping[promise.state()];\n    },\n\n    // Just validate field. Do not trigger any event.\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if the field is not in the given `group`.\n    // The argument `force` will force validation of empty fields.\n    // If a `value` is given, it will be validated instead of the value of the input.\n    whenValid: function whenValid() {\n      var _this11 = this;\n\n      var _ref10 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref10$force = _ref10.force;\n      var force = _ref10$force === undefined ? false : _ref10$force;\n      var value = _ref10.value;\n      var group = _ref10.group;\n      var _refreshed = _ref10._refreshed;\n\n      // Recompute options and rebind constraints to have latest changes\n      if (!_refreshed) this.refreshConstraints();\n      // do not validate a field if not the same as given validation group\n      if (group && !this._isInGroup(group)) return;\n\n      this.validationResult = true;\n\n      // A field without constraint is valid\n      if (!this.hasConstraints()) return $.when();\n\n      // Value could be passed as argument, needed to add more power to 'field:validate'\n      if ('undefined' === typeof value || null === value) value = this.getValue();\n\n      if (!this.needsValidation(value) && true !== force) return $.when();\n\n      var groupedConstraints = this._getGroupedConstraints();\n      var promises = [];\n      $.each(groupedConstraints, function (_, constraints) {\n        // Process one group of constraints at a time, we validate the constraints\n        // and combine the promises together.\n        var promise = ParsleyUtils__default.all($.map(constraints, function (constraint) {\n          return _this11._validateConstraint(value, constraint);\n        }));\n        promises.push(promise);\n        if (promise.state() === 'rejected') return false; // Interrupt processing if a group has already failed\n      });\n      return ParsleyUtils__default.all(promises);\n    },\n\n    // @returns a promise\n    _validateConstraint: function _validateConstraint(value, constraint) {\n      var _this12 = this;\n\n      var result = constraint.validate(value, this);\n      // Map false to a failed promise\n      if (false === result) result = $.Deferred().reject();\n      // Make sure we return a promise and that we record failures\n      return ParsleyUtils__default.all([result]).fail(function (errorMessage) {\n        if (!(_this12.validationResult instanceof Array)) _this12.validationResult = [];\n        _this12.validationResult.push({\n          assert: constraint,\n          errorMessage: 'string' === typeof errorMessage && errorMessage\n        });\n      });\n    },\n\n    // @returns Parsley field computed value that could be overrided or configured in DOM\n    getValue: function getValue() {\n      var value;\n\n      // Value could be overriden in DOM or with explicit options\n      if ('function' === typeof this.options.value) value = this.options.value(this);else if ('undefined' !== typeof this.options.value) value = this.options.value;else value = this.$element.val();\n\n      // Handle wrong DOM or configurations\n      if ('undefined' === typeof value || null === value) return '';\n\n      return this._handleWhitespace(value);\n    },\n\n    // Actualize options that could have change since previous validation\n    // Re-bind accordingly constraints (could be some new, removed or updated)\n    refreshConstraints: function refreshConstraints() {\n      return this.actualizeOptions()._bindConstraints();\n    },\n\n    /**\n    * Add a new constraint to a field\n    *\n    * @param {String}   name\n    * @param {Mixed}    requirements      optional\n    * @param {Number}   priority          optional\n    * @param {Boolean}  isDomConstraint   optional\n    */\n    addConstraint: function addConstraint(name, requirements, priority, isDomConstraint) {\n\n      if (window.Parsley._validatorRegistry.validators[name]) {\n        var constraint = new ConstraintFactory(this, name, requirements, priority, isDomConstraint);\n\n        // if constraint already exist, delete it and push new version\n        if ('undefined' !== this.constraintsByName[constraint.name]) this.removeConstraint(constraint.name);\n\n        this.constraints.push(constraint);\n        this.constraintsByName[constraint.name] = constraint;\n      }\n\n      return this;\n    },\n\n    // Remove a constraint\n    removeConstraint: function removeConstraint(name) {\n      for (var i = 0; i < this.constraints.length; i++) if (name === this.constraints[i].name) {\n        this.constraints.splice(i, 1);\n        break;\n      }\n      delete this.constraintsByName[name];\n      return this;\n    },\n\n    // Update a constraint (Remove + re-add)\n    updateConstraint: function updateConstraint(name, parameters, priority) {\n      return this.removeConstraint(name).addConstraint(name, parameters, priority);\n    },\n\n    // # Internals\n\n    // Internal only.\n    // Bind constraints from config + options + DOM\n    _bindConstraints: function _bindConstraints() {\n      var constraints = [];\n      var constraintsByName = {};\n\n      // clean all existing DOM constraints to only keep javascript user constraints\n      for (var i = 0; i < this.constraints.length; i++) if (false === this.constraints[i].isDomConstraint) {\n        constraints.push(this.constraints[i]);\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\n      }\n\n      this.constraints = constraints;\n      this.constraintsByName = constraintsByName;\n\n      // then re-add Parsley DOM-API constraints\n      for (var name in this.options) this.addConstraint(name, this.options[name], undefined, true);\n\n      // finally, bind special HTML5 constraints\n      return this._bindHtml5Constraints();\n    },\n\n    // Internal only.\n    // Bind specific HTML5 constraints to be HTML5 compliant\n    _bindHtml5Constraints: function _bindHtml5Constraints() {\n      // html5 required\n      if (this.$element.attr('required')) this.addConstraint('required', true, undefined, true);\n\n      // html5 pattern\n      if ('string' === typeof this.$element.attr('pattern')) this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n      // range\n      if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max')) this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n      // HTML5 min\n      else if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('min')) this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n        // HTML5 max\n        else if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('max')) this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n      // length\n      if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength')) this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n      // HTML5 minlength\n      else if ('undefined' !== typeof this.$element.attr('minlength')) this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n        // HTML5 maxlength\n        else if ('undefined' !== typeof this.$element.attr('maxlength')) this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n      // html5 types\n      var type = this.$element.attr('type');\n\n      if ('undefined' === typeof type) return this;\n\n      // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n      if ('number' === type) {\n        return this.addConstraint('type', ['number', {\n          step: this.$element.attr('step') || '1',\n          base: this.$element.attr('min') || this.$element.attr('value')\n        }], undefined, true);\n        // Regular other HTML5 supported types\n      } else if (/^(email|url|range)$/i.test(type)) {\n          return this.addConstraint('type', type, undefined, true);\n        }\n      return this;\n    },\n\n    // Internal only.\n    // Field is required if have required constraint without `false` value\n    _isRequired: function _isRequired() {\n      if ('undefined' === typeof this.constraintsByName.required) return false;\n\n      return false !== this.constraintsByName.required.requirements;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    _trigger: function _trigger(eventName) {\n      return this.trigger('field:' + eventName);\n    },\n\n    // Internal only\n    // Handles whitespace in a value\n    // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n    // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n    _handleWhitespace: function _handleWhitespace(value) {\n      if (true === this.options.trimValue) ParsleyUtils__default.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n      if ('squish' === this.options.whitespace) value = value.replace(/\\s{2,}/g, ' ');\n\n      if ('trim' === this.options.whitespace || 'squish' === this.options.whitespace || true === this.options.trimValue) value = ParsleyUtils__default.trimString(value);\n\n      return value;\n    },\n\n    // Internal only.\n    // Returns the constraints, grouped by descending priority.\n    // The result is thus an array of arrays of constraints.\n    _getGroupedConstraints: function _getGroupedConstraints() {\n      if (false === this.options.priorityEnabled) return [this.constraints];\n\n      var groupedConstraints = [];\n      var index = {};\n\n      // Create array unique of priorities\n      for (var i = 0; i < this.constraints.length; i++) {\n        var p = this.constraints[i].priority;\n        if (!index[p]) groupedConstraints.push(index[p] = []);\n        index[p].push(this.constraints[i]);\n      }\n      // Sort them by priority DESC\n      groupedConstraints.sort(function (a, b) {\n        return b[0].priority - a[0].priority;\n      });\n\n      return groupedConstraints;\n    }\n\n  };\n\n  var parsley_field = ParsleyField;\n\n  var ParsleyMultiple = function ParsleyMultiple() {\n    this.__class__ = 'ParsleyFieldMultiple';\n  };\n\n  ParsleyMultiple.prototype = {\n    // Add new `$element` sibling for multiple field\n    addElement: function addElement($element) {\n      this.$elements.push($element);\n\n      return this;\n    },\n\n    // See `ParsleyField.refreshConstraints()`\n    refreshConstraints: function refreshConstraints() {\n      var fieldConstraints;\n\n      this.constraints = [];\n\n      // Select multiple special treatment\n      if (this.$element.is('select')) {\n        this.actualizeOptions()._bindConstraints();\n\n        return this;\n      }\n\n      // Gather all constraints for each input in the multiple group\n      for (var i = 0; i < this.$elements.length; i++) {\n\n        // Check if element have not been dynamically removed since last binding\n        if (!$('html').has(this.$elements[i]).length) {\n          this.$elements.splice(i, 1);\n          continue;\n        }\n\n        fieldConstraints = this.$elements[i].data('ParsleyFieldMultiple').refreshConstraints().constraints;\n\n        for (var j = 0; j < fieldConstraints.length; j++) this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n      }\n\n      return this;\n    },\n\n    // See `ParsleyField.getValue()`\n    getValue: function getValue() {\n      // Value could be overriden in DOM\n      if ('function' === typeof this.options.value) return this.options.value(this);else if ('undefined' !== typeof this.options.value) return this.options.value;\n\n      // Radio input case\n      if (this.$element.is('input[type=radio]')) return this._findRelated().filter(':checked').val() || '';\n\n      // checkbox input case\n      if (this.$element.is('input[type=checkbox]')) {\n        var values = [];\n\n        this._findRelated().filter(':checked').each(function () {\n          values.push($(this).val());\n        });\n\n        return values;\n      }\n\n      // Select multiple case\n      if (this.$element.is('select') && null === this.$element.val()) return [];\n\n      // Default case that should never happen\n      return this.$element.val();\n    },\n\n    _init: function _init() {\n      this.$elements = [this.$element];\n\n      return this;\n    }\n  };\n\n  var ParsleyFactory = function ParsleyFactory(element, options, parsleyFormInstance) {\n    this.$element = $(element);\n\n    // If the element has already been bound, returns its saved Parsley instance\n    var savedparsleyFormInstance = this.$element.data('Parsley');\n    if (savedparsleyFormInstance) {\n\n      // If the saved instance has been bound without a ParsleyForm parent and there is one given in this call, add it\n      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n        savedparsleyFormInstance.parent = parsleyFormInstance;\n        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n      }\n\n      if ('object' === typeof options) {\n        $.extend(savedparsleyFormInstance.options, options);\n      }\n\n      return savedparsleyFormInstance;\n    }\n\n    // Parsley must be instantiated with a DOM element or jQuery $element\n    if (!this.$element.length) throw new Error('You must bind Parsley on an existing element.');\n\n    if ('undefined' !== typeof parsleyFormInstance && 'ParsleyForm' !== parsleyFormInstance.__class__) throw new Error('Parent instance must be a ParsleyForm instance');\n\n    this.parent = parsleyFormInstance || window.Parsley;\n    return this.init(options);\n  };\n\n  ParsleyFactory.prototype = {\n    init: function init(options) {\n      this.__class__ = 'Parsley';\n      this.__version__ = '2.6.1';\n      this.__id__ = ParsleyUtils__default.generateID();\n\n      // Pre-compute options\n      this._resetOptions(options);\n\n      // A ParsleyForm instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n      if (this.$element.is('form') || ParsleyUtils__default.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)) return this.bind('parsleyForm');\n\n      // Every other element is bound as a `ParsleyField` or `ParsleyFieldMultiple`\n      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n    },\n\n    isMultiple: function isMultiple() {\n      return this.$element.is('input[type=radio], input[type=checkbox]') || this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple');\n    },\n\n    // Multiples fields are a real nightmare :(\n    // Maybe some refactoring would be appreciated here...\n    handleMultiple: function handleMultiple() {\n      var _this13 = this;\n\n      var name;\n      var multiple;\n      var parsleyMultipleInstance;\n\n      // Handle multiple name\n      if (this.options.multiple) ; // We already have our 'multiple' identifier\n      else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length) this.options.multiple = name = this.$element.attr('name');else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length) this.options.multiple = this.$element.attr('id');\n\n      // Special select multiple input\n      if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n        this.options.multiple = this.options.multiple || this.__id__;\n        return this.bind('parsleyFieldMultiple');\n\n        // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n      } else if (!this.options.multiple) {\n          ParsleyUtils__default.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n          return this;\n        }\n\n      // Remove special chars\n      this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n      if ('undefined' !== typeof name) {\n        $('input[name=\"' + name + '\"]').each(function (i, input) {\n          if ($(input).is('input[type=radio], input[type=checkbox]')) $(input).attr(_this13.options.namespace + 'multiple', _this13.options.multiple);\n        });\n      }\n\n      // Check here if we don't already have a related multiple instance saved\n      var $previouslyRelated = this._findRelated();\n      for (var i = 0; i < $previouslyRelated.length; i++) {\n        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n        if ('undefined' !== typeof parsleyMultipleInstance) {\n\n          if (!this.$element.data('ParsleyFieldMultiple')) {\n            parsleyMultipleInstance.addElement(this.$element);\n          }\n\n          break;\n        }\n      }\n\n      // Create a secret ParsleyField instance for every multiple field. It will be stored in `data('ParsleyFieldMultiple')`\n      // And will be useful later to access classic `ParsleyField` stuff while being in a `ParsleyFieldMultiple` instance\n      this.bind('parsleyField', true);\n\n      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n    },\n\n    // Return proper `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`\n    bind: function bind(type, doNotStore) {\n      var parsleyInstance;\n\n      switch (type) {\n        case 'parsleyForm':\n          parsleyInstance = $.extend(new ParsleyForm(this.$element, this.domOptions, this.options), new ParsleyAbstract(), window.ParsleyExtend)._bindFields();\n          break;\n        case 'parsleyField':\n          parsleyInstance = $.extend(new parsley_field(this.$element, this.domOptions, this.options, this.parent), new ParsleyAbstract(), window.ParsleyExtend);\n          break;\n        case 'parsleyFieldMultiple':\n          parsleyInstance = $.extend(new parsley_field(this.$element, this.domOptions, this.options, this.parent), new ParsleyMultiple(), new ParsleyAbstract(), window.ParsleyExtend)._init();\n          break;\n        default:\n          throw new Error(type + 'is not a supported Parsley type');\n      }\n\n      if (this.options.multiple) ParsleyUtils__default.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n      if ('undefined' !== typeof doNotStore) {\n        this.$element.data('ParsleyFieldMultiple', parsleyInstance);\n\n        return parsleyInstance;\n      }\n\n      // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n      this.$element.data('Parsley', parsleyInstance);\n\n      // Tell the world we have a new ParsleyForm or ParsleyField instance!\n      parsleyInstance._actualizeTriggers();\n      parsleyInstance._trigger('init');\n\n      return parsleyInstance;\n    }\n  };\n\n  var vernums = $.fn.jquery.split('.');\n  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\n    throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\n  }\n  if (!vernums.forEach) {\n    ParsleyUtils__default.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\n  }\n  // Inherit `on`, `off` & `trigger` to Parsley:\n  var Parsley = $.extend(new ParsleyAbstract(), {\n    $element: $(document),\n    actualizeOptions: null,\n    _resetOptions: null,\n    Factory: ParsleyFactory,\n    version: '2.6.1'\n  });\n\n  // Supplement ParsleyField and Form with ParsleyAbstract\n  // This way, the constructors will have access to those methods\n  $.extend(parsley_field.prototype, ParsleyUI.Field, ParsleyAbstract.prototype);\n  $.extend(ParsleyForm.prototype, ParsleyUI.Form, ParsleyAbstract.prototype);\n  // Inherit actualizeOptions and _resetOptions:\n  $.extend(ParsleyFactory.prototype, ParsleyAbstract.prototype);\n\n  // ### jQuery API\n  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n  $.fn.parsley = $.fn.psly = function (options) {\n    if (this.length > 1) {\n      var instances = [];\n\n      this.each(function () {\n        instances.push($(this).parsley(options));\n      });\n\n      return instances;\n    }\n\n    // Return undefined if applied to non existing DOM element\n    if (!$(this).length) {\n      ParsleyUtils__default.warn('You must bind Parsley on an existing element.');\n\n      return;\n    }\n\n    return new ParsleyFactory(this, options);\n  };\n\n  // ### ParsleyField and ParsleyForm extension\n  // Ensure the extension is now defined if it wasn't previously\n  if ('undefined' === typeof window.ParsleyExtend) window.ParsleyExtend = {};\n\n  // ### Parsley config\n  // Inherit from ParsleyDefault, and copy over any existing values\n  Parsley.options = $.extend(ParsleyUtils__default.objectCreate(ParsleyDefaults), window.ParsleyConfig);\n  window.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n  // ### Globals\n  window.Parsley = window.psly = Parsley;\n  window.ParsleyUtils = ParsleyUtils__default;\n\n  // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\n  var registry = window.Parsley._validatorRegistry = new ParsleyValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\n  window.ParsleyValidator = {};\n  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n    window.Parsley[method] = $.proxy(registry, method);\n    window.ParsleyValidator[method] = function () {\n      var _window$Parsley;\n\n      ParsleyUtils__default.warnOnce('Accessing the method \\'' + method + '\\' through ParsleyValidator is deprecated. Simply call \\'window.Parsley.' + method + '(...)\\'');\n      return (_window$Parsley = window.Parsley)[method].apply(_window$Parsley, arguments);\n    };\n  });\n\n  // ### ParsleyUI\n  // Deprecated global object\n  window.Parsley.UI = ParsleyUI;\n  window.ParsleyUI = {\n    removeError: function removeError(instance, name, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      ParsleyUtils__default.warnOnce('Accessing ParsleyUI is deprecated. Call \\'removeError\\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');\n      return instance.removeError(name, { updateClass: updateClass });\n    },\n    getErrorsMessages: function getErrorsMessages(instance) {\n      ParsleyUtils__default.warnOnce('Accessing ParsleyUI is deprecated. Call \\'getErrorsMessages\\' on the instance directly.');\n      return instance.getErrorsMessages();\n    }\n  };\n  $.each('addError updateError'.split(' '), function (i, method) {\n    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      ParsleyUtils__default.warnOnce('Accessing ParsleyUI is deprecated. Call \\'' + method + '\\' on the instance directly. Please comment in issue 1073 as to your need to call this method.');\n      return instance[method](name, { message: message, assert: assert, updateClass: updateClass });\n    };\n  });\n\n  // ### PARSLEY auto-binding\n  // Prevent it by setting `ParsleyConfig.autoBind` to `false`\n  if (false !== window.ParsleyConfig.autoBind) {\n    $(function () {\n      // Works only on `data-parsley-validate`.\n      if ($('[data-parsley-validate]').length) $('[data-parsley-validate]').parsley();\n    });\n  }\n\n  var o = $({});\n  var deprecated = function deprecated() {\n    ParsleyUtils__default.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n  };\n\n  // Returns an event handler that calls `fn` with the arguments it expects\n  function adapt(fn, context) {\n    // Store to allow unbinding\n    if (!fn.parsleyAdaptedCallback) {\n      fn.parsleyAdaptedCallback = function () {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(this);\n        fn.apply(context || o, args);\n      };\n    }\n    return fn.parsleyAdaptedCallback;\n  }\n\n  var eventPrefix = 'parsley:';\n  // Converts 'parsley:form:validate' into 'form:validate'\n  function eventName(name) {\n    if (name.lastIndexOf(eventPrefix, 0) === 0) return name.substr(eventPrefix.length);\n    return name;\n  }\n\n  // $.listen is deprecated. Use Parsley.on instead.\n  $.listen = function (name, callback) {\n    var context;\n    deprecated();\n    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n      context = arguments[1];\n      callback = arguments[2];\n    }\n\n    if ('function' !== typeof callback) throw new Error('Wrong parameters');\n\n    window.Parsley.on(eventName(name), adapt(callback, context));\n  };\n\n  $.listenTo = function (instance, name, fn) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof ParsleyForm)) throw new Error('Must give Parsley instance');\n\n    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong parameters');\n\n    instance.on(eventName(name), adapt(fn));\n  };\n\n  $.unsubscribe = function (name, fn) {\n    deprecated();\n    if ('string' !== typeof name || 'function' !== typeof fn) throw new Error('Wrong arguments');\n    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n  };\n\n  $.unsubscribeTo = function (instance, name) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof ParsleyForm)) throw new Error('Must give Parsley instance');\n    instance.off(eventName(name));\n  };\n\n  $.unsubscribeAll = function (name) {\n    deprecated();\n    window.Parsley.off(eventName(name));\n    $('form,input,textarea,select').each(function () {\n      var instance = $(this).data('Parsley');\n      if (instance) {\n        instance.off(eventName(name));\n      }\n    });\n  };\n\n  // $.emit is deprecated. Use jQuery events instead.\n  $.emit = function (name, instance) {\n    var _instance;\n\n    deprecated();\n    var instanceGiven = instance instanceof parsley_field || instance instanceof ParsleyForm;\n    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n    args.unshift(eventName(name));\n    if (!instanceGiven) {\n      instance = window.Parsley;\n    }\n    (_instance = instance).trigger.apply(_instance, _toConsumableArray(args));\n  };\n\n  var pubsub = {};\n\n  $.extend(true, Parsley, {\n    asyncValidators: {\n      'default': {\n        fn: function fn(xhr) {\n          // By default, only status 2xx are deemed successful.\n          // Note: we use status instead of state() because responses with status 200\n          // but invalid messages (e.g. an empty body for content type set to JSON) will\n          // result in state() === 'rejected'.\n          return xhr.status >= 200 && xhr.status < 300;\n        },\n        url: false\n      },\n      reverse: {\n        fn: function fn(xhr) {\n          // If reverse option is set, a failing ajax request is considered successful\n          return xhr.status < 200 || xhr.status >= 300;\n        },\n        url: false\n      }\n    },\n\n    addAsyncValidator: function addAsyncValidator(name, fn, url, options) {\n      Parsley.asyncValidators[name] = {\n        fn: fn,\n        url: url || false,\n        options: options || {}\n      };\n\n      return this;\n    }\n\n  });\n\n  Parsley.addValidator('remote', {\n    requirementType: {\n      '': 'string',\n      'validator': 'string',\n      'reverse': 'boolean',\n      'options': 'object'\n    },\n\n    validateString: function validateString(value, url, options, instance) {\n      var data = {};\n      var ajaxOptions;\n      var csr;\n      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\n\n      if ('undefined' === typeof Parsley.asyncValidators[validator]) throw new Error('Calling an undefined async validator: `' + validator + '`');\n\n      url = Parsley.asyncValidators[validator].url || url;\n\n      // Fill current value\n      if (url.indexOf('{value}') > -1) {\n        url = url.replace('{value}', encodeURIComponent(value));\n      } else {\n        data[instance.$element.attr('name') || instance.$element.attr('id')] = value;\n      }\n\n      // Merge options passed in from the function with the ones in the attribute\n      var remoteOptions = $.extend(true, options.options || {}, Parsley.asyncValidators[validator].options);\n\n      // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\n      ajaxOptions = $.extend(true, {}, {\n        url: url,\n        data: data,\n        type: 'GET'\n      }, remoteOptions);\n\n      // Generate store key based on ajax options\n      instance.trigger('field:ajaxoptions', instance, ajaxOptions);\n\n      csr = $.param(ajaxOptions);\n\n      // Initialise querry cache\n      if ('undefined' === typeof Parsley._remoteCache) Parsley._remoteCache = {};\n\n      // Try to retrieve stored xhr\n      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\n\n      var handleXhr = function handleXhr() {\n        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\n        if (!result) // Map falsy results to rejected promise\n          result = $.Deferred().reject();\n        return $.when(result);\n      };\n\n      return xhr.then(handleXhr, handleXhr);\n    },\n\n    priority: -1\n  });\n\n  Parsley.on('form:submit', function () {\n    Parsley._remoteCache = {};\n  });\n\n  window.ParsleyExtend.addAsyncValidator = function () {\n    ParsleyUtils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\n    return Parsley.addAsyncValidator.apply(Parsley, arguments);\n  };\n\n  // This is included with the Parsley library itself,\n  // thus there is no use in adding it to your project.\n  Parsley.addMessages('en', {\n    defaultMessage: \"This value seems to be invalid.\",\n    type: {\n      email: \"This value should be a valid email.\",\n      url: \"This value should be a valid url.\",\n      number: \"This value should be a valid number.\",\n      integer: \"This value should be a valid integer.\",\n      digits: \"This value should be digits.\",\n      alphanum: \"This value should be alphanumeric.\"\n    },\n    notblank: \"This value should not be blank.\",\n    required: \"This value is required.\",\n    pattern: \"This value seems to be invalid.\",\n    min: \"This value should be greater than or equal to %s.\",\n    max: \"This value should be lower than or equal to %s.\",\n    range: \"This value should be between %s and %s.\",\n    minlength: \"This value is too short. It should have %s characters or more.\",\n    maxlength: \"This value is too long. It should have %s characters or fewer.\",\n    length: \"This value length is invalid. It should be between %s and %s characters long.\",\n    mincheck: \"You must select at least %s choices.\",\n    maxcheck: \"You must select %s choices or fewer.\",\n    check: \"You must select between %s and %s choices.\",\n    equalto: \"This value should be the same.\"\n  });\n\n  Parsley.setLocale('en');\n\n  /**\n   * inputevent - Alleviate browser bugs for input events\n   * https://github.com/marcandre/inputevent\n   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\n   * @author Marc-Andre Lafortune <github@marc-andre.ca>\n   * @license MIT\n   */\n\n  function InputEvent() {\n    var _this14 = this;\n\n    var globals = window || global;\n\n    // Slightly odd way construct our object. This way methods are force bound.\n    // Used to test for duplicate library.\n    $.extend(this, {\n\n      // For browsers that do not support isTrusted, assumes event is native.\n      isNativeEvent: function isNativeEvent(evt) {\n        return evt.originalEvent && evt.originalEvent.isTrusted !== false;\n      },\n\n      fakeInputEvent: function fakeInputEvent(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          $(evt.target).trigger('input');\n        }\n      },\n\n      misbehaves: function misbehaves(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          _this14.behavesOk(evt);\n          $(document).on('change.inputevent', evt.data.selector, _this14.fakeInputEvent);\n          _this14.fakeInputEvent(evt);\n        }\n      },\n\n      behavesOk: function behavesOk(evt) {\n        if (_this14.isNativeEvent(evt)) {\n          $(document) // Simply unbinds the testing handler\n          .off('input.inputevent', evt.data.selector, _this14.behavesOk).off('change.inputevent', evt.data.selector, _this14.misbehaves);\n        }\n      },\n\n      // Bind the testing handlers\n      install: function install() {\n        if (globals.inputEventPatched) {\n          return;\n        }\n        globals.inputEventPatched = '0.0.3';\n        var _arr = ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]'];\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var selector = _arr[_i];\n          $(document).on('input.inputevent', selector, { selector: selector }, _this14.behavesOk).on('change.inputevent', selector, { selector: selector }, _this14.misbehaves);\n        }\n      },\n\n      uninstall: function uninstall() {\n        delete globals.inputEventPatched;\n        $(document).off('.inputevent');\n      }\n\n    });\n  };\n\n  var inputevent = new InputEvent();\n\n  inputevent.install();\n\n  var parsley = Parsley;\n\n  return parsley;\n});\n//# sourceMappingURL=parsley.js.map\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) :\n  typeof define === 'function' && define.amd ? define(['jquery'], factory) :\n  global.parsley = factory(global.$)\n}(this, function ($) { 'use strict';\n\n  var globalID = 1;\n  var pastWarnings = {};\n\n  var ParsleyUtils__ParsleyUtils = {\n    // Parsley DOM-API\n    // returns object from dom attributes and values\n    attr: function ($element, namespace, obj) {\n      var i;\n      var attribute;\n      var attributes;\n      var regex = new RegExp('^' + namespace, 'i');\n\n      if ('undefined' === typeof obj)\n        obj = {};\n      else {\n        // Clear all own properties. This won't affect prototype's values\n        for (i in obj) {\n          if (obj.hasOwnProperty(i))\n            delete obj[i];\n        }\n      }\n\n      if ('undefined' === typeof $element || 'undefined' === typeof $element[0])\n        return obj;\n\n      attributes = $element[0].attributes;\n      for (i = attributes.length; i--; ) {\n        attribute = attributes[i];\n\n        if (attribute && attribute.specified && regex.test(attribute.name)) {\n          obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n        }\n      }\n\n      return obj;\n    },\n\n    checkAttr: function ($element, namespace, checkAttr) {\n      return $element.is('[' + namespace + checkAttr + ']');\n    },\n\n    setAttr: function ($element, namespace, attr, value) {\n      $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n    },\n\n    generateID: function () {\n      return '' + globalID++;\n    },\n\n    /** Third party functions **/\n    // Zepto deserialize function\n    deserializeValue: function (value) {\n      var num;\n\n      try {\n        return value ?\n          value == \"true\" ||\n          (value == \"false\" ? false :\n          value == \"null\" ? null :\n          !isNaN(num = Number(value)) ? num :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value)\n          : value;\n      } catch (e) { return value; }\n    },\n\n    // Zepto camelize function\n    camelize: function (str) {\n      return str.replace(/-+(.)?/g, function (match, chr) {\n        return chr ? chr.toUpperCase() : '';\n      });\n    },\n\n    // Zepto dasherize function\n    dasherize: function (str) {\n      return str.replace(/::/g, '/')\n        .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n        .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n        .replace(/_/g, '-')\n        .toLowerCase();\n    },\n\n    warn: function () {\n      if (window.console && 'function' === typeof window.console.warn)\n        window.console.warn(...arguments);\n    },\n\n    warnOnce: function(msg) {\n      if (!pastWarnings[msg]) {\n        pastWarnings[msg] = true;\n        this.warn(...arguments);\n      }\n    },\n\n    _resetWarnings: function () {\n      pastWarnings = {};\n    },\n\n    trimString: function(string) {\n      return string.replace(/^\\s+|\\s+$/g, '');\n    },\n\n    namespaceEvents: function(events, namespace) {\n      events = this.trimString(events || '').split(/\\s+/);\n      if (!events[0])\n        return '';\n      return $.map(events, evt => `${evt}.${namespace}`).join(' ');\n    },\n\n    difference: function(array, remove) {\n      // This is O(N^2), should be optimized\n      let result = [];\n      $.each(array, (_, elem) => {\n        if (remove.indexOf(elem) == -1)\n          result.push(elem);\n      });\n      return result;\n    },\n\n    // Alter-ego to native Promise.all, but for jQuery\n    all: function(promises) {\n      // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\n      return $.when(...promises, 42, 42);\n    },\n\n    // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n    objectCreate: Object.create || (function () {\n      var Object = function () {};\n      return function (prototype) {\n        if (arguments.length > 1) {\n          throw Error('Second argument not supported');\n        }\n        if (typeof prototype != 'object') {\n          throw TypeError('Argument must be an object');\n        }\n        Object.prototype = prototype;\n        var result = new Object();\n        Object.prototype = null;\n        return result;\n      };\n    })(),\n\n    _SubmitSelector: 'input[type=\"submit\"], button:submit'\n  };\n\n  var ParsleyUtils__default = ParsleyUtils__ParsleyUtils;\n\n  // All these options could be overriden and specified directly in DOM using\n  // `data-parsley-` default DOM-API\n  // eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n  // eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\n  var ParsleyDefaults = {\n    // ### General\n\n    // Default data-namespace for DOM API\n    namespace: 'data-parsley-',\n\n    // Supported inputs by default\n    inputs: 'input, textarea, select',\n\n    // Excluded inputs by default\n    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n    // Stop validating field on highest priority failing constraint\n    priorityEnabled: true,\n\n    // ### Field only\n\n    // identifier used to group together inputs (e.g. radio buttons...)\n    multiple: null,\n\n    // identifier (or array of identifiers) used to validate only a select group of inputs\n    group: null,\n\n    // ### UI\n    // Enable\\Disable error messages\n    uiEnabled: true,\n\n    // Key events threshold before validation\n    validationThreshold: 3,\n\n    // Focused field on form validation error. 'first'|'last'|'none'\n    focus: 'first',\n\n    // event(s) that will trigger validation before first failure. eg: `input`...\n    trigger: false,\n\n    // event(s) that will trigger validation after first failure.\n    triggerAfterFailure: 'input',\n\n    // Class that would be added on every failing validation Parsley field\n    errorClass: 'parsley-error',\n\n    // Same for success validation\n    successClass: 'parsley-success',\n\n    // Return the `$element` that will receive these above success or error classes\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    classHandler: function (ParsleyField) {},\n\n    // Return the `$element` where errors will be appended\n    // Could also be (and given directly from DOM) a valid selector like `'#div'`\n    errorsContainer: function (ParsleyField) {},\n\n    // ul elem that would receive errors' list\n    errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n    // li elem that would receive error message\n    errorTemplate: '<li></li>'\n  };\n\n  var ParsleyAbstract = function () {\n    this.__id__ = ParsleyUtils__default.generateID();\n  };\n\n  ParsleyAbstract.prototype = {\n    asyncSupport: true, // Deprecated\n\n    _pipeAccordingToValidationResult: function () {\n      var pipe = () => {\n        var r = $.Deferred();\n        if (true !== this.validationResult)\n          r.reject();\n        return r.resolve().promise();\n      };\n      return [pipe, pipe];\n    },\n\n    actualizeOptions: function () {\n      ParsleyUtils__default.attr(this.$element, this.options.namespace, this.domOptions);\n      if (this.parent && this.parent.actualizeOptions)\n        this.parent.actualizeOptions();\n      return this;\n    },\n\n    _resetOptions: function (initOptions) {\n      this.domOptions = ParsleyUtils__default.objectCreate(this.parent.options);\n      this.options = ParsleyUtils__default.objectCreate(this.domOptions);\n      // Shallow copy of ownProperties of initOptions:\n      for (var i in initOptions) {\n        if (initOptions.hasOwnProperty(i))\n          this.options[i] = initOptions[i];\n      }\n      this.actualizeOptions();\n    },\n\n    _listeners: null,\n\n    // Register a callback for the given event name\n    // Callback is called with context as the first argument and the `this`\n    // The context is the current parsley instance, or window.Parsley if global\n    // A return value of `false` will interrupt the calls\n    on: function (name, fn) {\n      this._listeners = this._listeners || {};\n      var queue = this._listeners[name] = this._listeners[name] || [];\n      queue.push(fn);\n\n      return this;\n    },\n\n    // Deprecated. Use `on` instead\n    subscribe: function(name, fn) {\n      $.listenTo(this, name.toLowerCase(), fn);\n    },\n\n    // Unregister a callback (or all if none is given) for the given event name\n    off: function (name, fn) {\n      var queue = this._listeners && this._listeners[name];\n      if (queue) {\n        if (!fn) {\n          delete this._listeners[name];\n        } else {\n          for (var i = queue.length; i--; )\n            if (queue[i] === fn)\n              queue.splice(i, 1);\n        }\n      }\n      return this;\n    },\n\n    // Deprecated. Use `off`\n    unsubscribe: function(name, fn) {\n      $.unsubscribeTo(this, name.toLowerCase());\n    },\n\n    // Trigger an event of the given name\n    // A return value of `false` interrupts the callback chain\n    // Returns false if execution was interrupted\n    trigger: function (name, target, extraArg) {\n      target = target || this;\n      var queue = this._listeners && this._listeners[name];\n      var result;\n      var parentResult;\n      if (queue) {\n        for (var i = queue.length; i--; ) {\n          result = queue[i].call(target, target, extraArg);\n          if (result === false) return result;\n        }\n      }\n      if (this.parent) {\n        return this.parent.trigger(name, target, extraArg);\n      }\n      return true;\n    },\n\n    // Reset UI\n    reset: function () {\n      // Field case: just emit a reset event for UI\n      if ('ParsleyForm' !== this.__class__) {\n        this._resetUI();\n        return this._trigger('reset');\n      }\n\n      // Form case: emit a reset event for each field\n      for (var i = 0; i < this.fields.length; i++)\n        this.fields[i].reset();\n\n      this._trigger('reset');\n    },\n\n    // Destroy Parsley instance (+ UI)\n    destroy: function () {\n      // Field case: emit destroy event to clean UI and then destroy stored instance\n      this._destroyUI();\n      if ('ParsleyForm' !== this.__class__) {\n        this.$element.removeData('Parsley');\n        this.$element.removeData('ParsleyFieldMultiple');\n        this._trigger('destroy');\n\n        return;\n      }\n\n      // Form case: destroy all its fields and then destroy stored instance\n      for (var i = 0; i < this.fields.length; i++)\n        this.fields[i].destroy();\n\n      this.$element.removeData('Parsley');\n      this._trigger('destroy');\n    },\n\n    asyncIsValid: function (group, force) {\n      ParsleyUtils__default.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\n      return this.whenValid({group, force});\n    },\n\n    _findRelated: function () {\n      return this.options.multiple ?\n        this.parent.$element.find(`[${this.options.namespace}multiple=\"${this.options.multiple}\"]`)\n      : this.$element;\n    }\n  };\n\n  var requirementConverters = {\n    string: function(string) {\n      return string;\n    },\n    integer: function(string) {\n      if (isNaN(string))\n        throw 'Requirement is not an integer: \"' + string + '\"';\n      return parseInt(string, 10);\n    },\n    number: function(string) {\n      if (isNaN(string))\n        throw 'Requirement is not a number: \"' + string + '\"';\n      return parseFloat(string);\n    },\n    reference: function(string) { // Unused for now\n      var result = $(string);\n      if (result.length === 0)\n        throw 'No such reference: \"' + string + '\"';\n      return result;\n    },\n    boolean: function(string) {\n      return string !== 'false';\n    },\n    object: function(string) {\n      return ParsleyUtils__default.deserializeValue(string);\n    },\n    regexp: function(regexp) {\n      var flags = '';\n\n      // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n      if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\n        // Replace the regexp literal string with the first match group: ([gimy]*)\n        // If no flag is present, this will be a blank string\n        flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\n        // Again, replace the regexp literal string with the first match group:\n        // everything excluding the opening and closing slashes and the flags\n        regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n      } else {\n        // Anchor regexp:\n        regexp = '^' + regexp + '$';\n      }\n      return new RegExp(regexp, flags);\n    }\n  };\n\n  var convertArrayRequirement = function(string, length) {\n    var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n    if (!m)\n      throw 'Requirement is not an array: \"' + string + '\"';\n    var values = m[1].split(',').map(ParsleyUtils__default.trimString);\n    if (values.length !== length)\n      throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n    return values;\n  };\n\n  var convertRequirement = function(requirementType, string) {\n    var converter = requirementConverters[requirementType || 'string'];\n    if (!converter)\n      throw 'Unknown requirement specification: \"' + requirementType + '\"';\n    return converter(string);\n  };\n\n  var convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\n    var main = null;\n    var extra = {};\n    for (var key in requirementSpec) {\n      if (key) {\n        var value = extraOptionReader(key);\n        if ('string' === typeof value)\n          value = convertRequirement(requirementSpec[key], value);\n        extra[key] = value;\n      } else {\n        main = convertRequirement(requirementSpec[key], string);\n      }\n    }\n    return [main, extra];\n  };\n\n  // A Validator needs to implement the methods `validate` and `parseRequirements`\n\n  var ParsleyValidator = function(spec) {\n    $.extend(true, this, spec);\n  };\n\n  ParsleyValidator.prototype = {\n    // Returns `true` iff the given `value` is valid according the given requirements.\n    validate: function(value, requirementFirstArg) {\n      if (this.fn) { // Legacy style validator\n\n        if (arguments.length > 3)  // If more args then value, requirement, instance...\n          requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\n        return this.fn.call(this, value, requirementFirstArg);\n      }\n\n      if ($.isArray(value)) {\n        if (!this.validateMultiple)\n          throw 'Validator `' + this.name + '` does not handle multiple values';\n        return this.validateMultiple(...arguments);\n      } else {\n        if (this.validateNumber) {\n          if (isNaN(value))\n            return false;\n          arguments[0] = parseFloat(arguments[0]);\n          return this.validateNumber(...arguments);\n        }\n        if (this.validateString) {\n          return this.validateString(...arguments);\n        }\n        throw 'Validator `' + this.name + '` only handles multiple values';\n      }\n    },\n\n    // Parses `requirements` into an array of arguments,\n    // according to `this.requirementType`\n    parseRequirements: function(requirements, extraOptionReader) {\n      if ('string' !== typeof requirements) {\n        // Assume requirement already parsed\n        // but make sure we return an array\n        return $.isArray(requirements) ? requirements : [requirements];\n      }\n      var type = this.requirementType;\n      if ($.isArray(type)) {\n        var values = convertArrayRequirement(requirements, type.length);\n        for (var i = 0; i < values.length; i++)\n          values[i] = convertRequirement(type[i], values[i]);\n        return values;\n      } else if ($.isPlainObject(type)) {\n        return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n      } else {\n        return [convertRequirement(type, requirements)];\n      }\n    },\n    // Defaults:\n    requirementType: 'string',\n\n    priority: 2\n\n  };\n\n  var ParsleyValidatorRegistry = function (validators, catalog) {\n    this.__class__ = 'ParsleyValidatorRegistry';\n\n    // Default Parsley locale is en\n    this.locale = 'en';\n\n    this.init(validators || {}, catalog || {});\n  };\n\n  var typeRegexes =  {\n    email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n    // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\n    number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\n\n    integer: /^-?\\d+$/,\n\n    digits: /^\\d+$/,\n\n    alphanum: /^\\w+$/i,\n\n    url: new RegExp(\n        \"^\" +\n          // protocol identifier\n          \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n          // user:pass authentication\n          \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n          \"(?:\" +\n            // IP address exclusion\n            // private & local networks\n            // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n            // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n            // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n            // IP address dotted notation octets\n            // excludes loopback network 0.0.0.0\n            // excludes reserved space >= 224.0.0.0\n            // excludes network & broacast addresses\n            // (first & last IP address of each class)\n            \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n            \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n            \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n          \"|\" +\n            // host name\n            \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n            // domain name\n            \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n            // TLD identifier\n            \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\n          \")\" +\n          // port number\n          \"(?::\\\\d{2,5})?\" +\n          // resource path\n          \"(?:/\\\\S*)?\" +\n        \"$\", 'i'\n      )\n  };\n  typeRegexes.range = typeRegexes.number;\n\n  // See http://stackoverflow.com/a/10454560/8279\n  var decimalPlaces = num => {\n    var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    if (!match) { return 0; }\n    return Math.max(\n         0,\n         // Number of digits right of decimal point.\n         (match[1] ? match[1].length : 0) -\n         // Adjust for scientific notation.\n         (match[2] ? +match[2] : 0));\n  };\n\n  ParsleyValidatorRegistry.prototype = {\n    init: function (validators, catalog) {\n      this.catalog = catalog;\n      // Copy prototype's validators:\n      this.validators = $.extend({}, this.validators);\n\n      for (var name in validators)\n        this.addValidator(name, validators[name].fn, validators[name].priority);\n\n      window.Parsley.trigger('parsley:validator:init');\n    },\n\n    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n    setLocale: function (locale) {\n      if ('undefined' === typeof this.catalog[locale])\n        throw new Error(locale + ' is not available in the catalog');\n\n      this.locale = locale;\n\n      return this;\n    },\n\n    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n    addCatalog: function (locale, messages, set) {\n      if ('object' === typeof messages)\n        this.catalog[locale] = messages;\n\n      if (true === set)\n        return this.setLocale(locale);\n\n      return this;\n    },\n\n    // Add a specific message for a given constraint in a given locale\n    addMessage: function (locale, name, message) {\n      if ('undefined' === typeof this.catalog[locale])\n        this.catalog[locale] = {};\n\n      this.catalog[locale][name] = message;\n\n      return this;\n    },\n\n    // Add messages for a given locale\n    addMessages: function (locale, nameMessageObject) {\n      for (var name in nameMessageObject)\n        this.addMessage(locale, name, nameMessageObject[name]);\n\n      return this;\n    },\n\n    // Add a new validator\n    //\n    //    addValidator('custom', {\n    //        requirementType: ['integer', 'integer'],\n    //        validateString: function(value, from, to) {},\n    //        priority: 22,\n    //        messages: {\n    //          en: \"Hey, that's no good\",\n    //          fr: \"Aye aye, pas bon du tout\",\n    //        }\n    //    })\n    //\n    // Old API was addValidator(name, function, priority)\n    //\n    addValidator: function (name, arg1, arg2) {\n      if (this.validators[name])\n        ParsleyUtils__default.warn('Validator \"' + name + '\" is already defined.');\n      else if (ParsleyDefaults.hasOwnProperty(name)) {\n        ParsleyUtils__default.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n        return;\n      }\n      return this._setValidator(...arguments);\n    },\n\n    updateValidator: function (name, arg1, arg2) {\n      if (!this.validators[name]) {\n        ParsleyUtils__default.warn('Validator \"' + name + '\" is not already defined.');\n        return this.addValidator(...arguments);\n      }\n      return this._setValidator(...arguments);\n    },\n\n    removeValidator: function (name) {\n      if (!this.validators[name])\n        ParsleyUtils__default.warn('Validator \"' + name + '\" is not defined.');\n\n      delete this.validators[name];\n\n      return this;\n    },\n\n    _setValidator: function (name, validator, priority) {\n      if ('object' !== typeof validator) {\n        // Old style validator, with `fn` and `priority`\n        validator = {\n          fn: validator,\n          priority: priority\n        };\n      }\n      if (!validator.validate) {\n        validator = new ParsleyValidator(validator);\n      }\n      this.validators[name] = validator;\n\n      for (var locale in validator.messages || {})\n        this.addMessage(locale, name, validator.messages[locale]);\n\n      return this;\n    },\n\n    getErrorMessage: function (constraint) {\n      var message;\n\n      // Type constraints are a bit different, we have to match their requirements too to find right error message\n      if ('type' === constraint.name) {\n        var typeMessages = this.catalog[this.locale][constraint.name] || {};\n        message = typeMessages[constraint.requirements];\n      } else\n        message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n      return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n    },\n\n    // Kind of light `sprintf()` implementation\n    formatMessage: function (string, parameters) {\n      if ('object' === typeof parameters) {\n        for (var i in parameters)\n          string = this.formatMessage(string, parameters[i]);\n\n        return string;\n      }\n\n      return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\n    },\n\n    // Here is the Parsley default validators list.\n    // A validator is an object with the following key values:\n    //  - priority: an integer\n    //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n    //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n    // Alternatively, a validator can be a function that returns such an object\n    //\n    validators: {\n      notblank: {\n        validateString: function(value) {\n          return /\\S/.test(value);\n        },\n        priority: 2\n      },\n      required: {\n        validateMultiple: function(values) {\n          return values.length > 0;\n        },\n        validateString: function(value) {\n          return /\\S/.test(value);\n        },\n        priority: 512\n      },\n      type: {\n        validateString: function(value, type, {step = 'any', base = 0} = {}) {\n          var regex = typeRegexes[type];\n          if (!regex) {\n            throw new Error('validator type `' + type + '` is not supported');\n          }\n          if (!regex.test(value))\n            return false;\n          if ('number' === type) {\n            if (!/^any$/i.test(step || '')) {\n              var nb = Number(value);\n              var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\n              if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\n                return false;\n              // Be careful of rounding errors by using integers.\n              var toInt = f => Math.round(f * Math.pow(10, decimals));\n              if ((toInt(nb) - toInt(base)) % toInt(step) != 0)\n                return false;\n            }\n          }\n          return true;\n        },\n        requirementType: {\n          '': 'string',\n          step: 'string',\n          base: 'number'\n        },\n        priority: 256\n      },\n      pattern: {\n        validateString: function(value, regexp) {\n          return regexp.test(value);\n        },\n        requirementType: 'regexp',\n        priority: 64\n      },\n      minlength: {\n        validateString: function (value, requirement) {\n          return value.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxlength: {\n        validateString: function (value, requirement) {\n          return value.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      length: {\n        validateString: function (value, min, max) {\n          return value.length >= min && value.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      mincheck: {\n        validateMultiple: function (values, requirement) {\n          return values.length >= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      maxcheck: {\n        validateMultiple: function (values, requirement) {\n          return values.length <= requirement;\n        },\n        requirementType: 'integer',\n        priority: 30\n      },\n      check: {\n        validateMultiple: function (values, min, max) {\n          return values.length >= min && values.length <= max;\n        },\n        requirementType: ['integer', 'integer'],\n        priority: 30\n      },\n      min: {\n        validateNumber: function (value, requirement) {\n          return value >= requirement;\n        },\n        requirementType: 'number',\n        priority: 30\n      },\n      max: {\n        validateNumber: function (value, requirement) {\n          return value <= requirement;\n        },\n        requirementType: 'number',\n        priority: 30\n      },\n      range: {\n        validateNumber: function (value, min, max) {\n          return value >= min && value <= max;\n        },\n        requirementType: ['number', 'number'],\n        priority: 30\n      },\n      equalto: {\n        validateString: function (value, refOrValue) {\n          var $reference = $(refOrValue);\n          if ($reference.length)\n            return value === $reference.val();\n          else\n            return value === refOrValue;\n        },\n        priority: 256\n      }\n    }\n  };\n\n  var ParsleyUI = {};\n\n  var diffResults = function (newResult, oldResult, deep) {\n    var added = [];\n    var kept = [];\n\n    for (var i = 0; i < newResult.length; i++) {\n      var found = false;\n\n      for (var j = 0; j < oldResult.length; j++)\n        if (newResult[i].assert.name === oldResult[j].assert.name) {\n          found = true;\n          break;\n        }\n\n      if (found)\n        kept.push(newResult[i]);\n      else\n        added.push(newResult[i]);\n    }\n\n    return {\n      kept: kept,\n      added: added,\n      removed: !deep ? diffResults(oldResult, newResult, true).added : []\n    };\n  };\n\n  ParsleyUI.Form = {\n\n    _actualizeTriggers: function () {\n      this.$element.on('submit.Parsley', evt => { this.onSubmitValidate(evt); });\n      this.$element.on('click.Parsley', ParsleyUtils__default._SubmitSelector, evt => { this.onSubmitButton(evt); });\n\n      // UI could be disabled\n      if (false === this.options.uiEnabled)\n        return;\n\n      this.$element.attr('novalidate', '');\n    },\n\n    focus: function () {\n      this._focusedField = null;\n\n      if (true === this.validationResult || 'none' === this.options.focus)\n        return null;\n\n      for (var i = 0; i < this.fields.length; i++) {\n        var field = this.fields[i];\n        if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n          this._focusedField = field.$element;\n          if ('first' === this.options.focus)\n            break;\n        }\n      }\n\n      if (null === this._focusedField)\n        return null;\n\n      return this._focusedField.focus();\n    },\n\n    _destroyUI: function () {\n      // Reset all event listeners\n      this.$element.off('.Parsley');\n    }\n\n  };\n\n  ParsleyUI.Field = {\n\n    _reflowUI: function () {\n      this._buildUI();\n\n      // If this field doesn't have an active UI don't bother doing something\n      if (!this._ui)\n        return;\n\n      // Diff between two validation results\n      var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\n\n      // Then store current validation result for next reflow\n      this._ui.lastValidationResult = this.validationResult;\n\n      // Handle valid / invalid / none field class\n      this._manageStatusClass();\n\n      // Add, remove, updated errors messages\n      this._manageErrorsMessages(diff);\n\n      // Triggers impl\n      this._actualizeTriggers();\n\n      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n      if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\n        this._failedOnce = true;\n        this._actualizeTriggers();\n      }\n    },\n\n    // Returns an array of field's error message(s)\n    getErrorsMessages: function () {\n      // No error message, field is valid\n      if (true === this.validationResult)\n        return [];\n\n      var messages = [];\n\n      for (var i = 0; i < this.validationResult.length; i++)\n        messages.push(this.validationResult[i].errorMessage ||\n         this._getErrorMessage(this.validationResult[i].assert));\n\n      return messages;\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    addError: function (name, {message, assert, updateClass = true} = {}) {\n      this._buildUI();\n      this._addError(name, {message, assert});\n\n      if (updateClass)\n        this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    updateError: function (name, {message, assert, updateClass = true} = {}) {\n      this._buildUI();\n      this._updateError(name, {message, assert});\n\n      if (updateClass)\n        this._errorClass();\n    },\n\n    // It's a goal of Parsley that this method is no longer required [#1073]\n    removeError: function (name, {updateClass = true} = {}) {\n      this._buildUI();\n      this._removeError(name);\n\n      // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\n      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n      if (updateClass)\n        this._manageStatusClass();\n    },\n\n    _manageStatusClass: function () {\n      if (this.hasConstraints() && this.needsValidation() && true === this.validationResult)\n        this._successClass();\n      else if (this.validationResult.length > 0)\n        this._errorClass();\n      else\n        this._resetClass();\n    },\n\n    _manageErrorsMessages: function (diff) {\n      if ('undefined' !== typeof this.options.errorsMessagesDisabled)\n        return;\n\n      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n      if ('undefined' !== typeof this.options.errorMessage) {\n        if ((diff.added.length || diff.kept.length)) {\n          this._insertErrorWrapper();\n\n          if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\n            this._ui.$errorsWrapper\n              .append(\n                $(this.options.errorTemplate)\n                .addClass('parsley-custom-error-message')\n              );\n\n          return this._ui.$errorsWrapper\n            .addClass('filled')\n            .find('.parsley-custom-error-message')\n            .html(this.options.errorMessage);\n        }\n\n        return this._ui.$errorsWrapper\n          .removeClass('filled')\n          .find('.parsley-custom-error-message')\n          .remove();\n      }\n\n      // Show, hide, update failing constraints messages\n      for (var i = 0; i < diff.removed.length; i++)\n        this._removeError(diff.removed[i].assert.name);\n\n      for (i = 0; i < diff.added.length; i++)\n        this._addError(diff.added[i].assert.name, {message: diff.added[i].errorMessage, assert: diff.added[i].assert});\n\n      for (i = 0; i < diff.kept.length; i++)\n        this._updateError(diff.kept[i].assert.name, {message: diff.kept[i].errorMessage, assert: diff.kept[i].assert});\n    },\n\n\n    _addError: function (name, {message, assert}) {\n      this._insertErrorWrapper();\n      this._ui.$errorsWrapper\n        .addClass('filled')\n        .append(\n          $(this.options.errorTemplate)\n          .addClass('parsley-' + name)\n          .html(message || this._getErrorMessage(assert))\n        );\n    },\n\n    _updateError: function (name, {message, assert}) {\n      this._ui.$errorsWrapper\n        .addClass('filled')\n        .find('.parsley-' + name)\n        .html(message || this._getErrorMessage(assert));\n    },\n\n    _removeError: function (name) {\n      this._ui.$errorsWrapper\n        .removeClass('filled')\n        .find('.parsley-' + name)\n        .remove();\n    },\n\n    _getErrorMessage: function (constraint) {\n      var customConstraintErrorMessage = constraint.name + 'Message';\n\n      if ('undefined' !== typeof this.options[customConstraintErrorMessage])\n        return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\n\n      return window.Parsley.getErrorMessage(constraint);\n    },\n\n    _buildUI: function () {\n      // UI could be already built or disabled\n      if (this._ui || false === this.options.uiEnabled)\n        return;\n\n      var _ui = {};\n\n      // Give field its Parsley id in DOM\n      this.$element.attr(this.options.namespace + 'id', this.__id__);\n\n      /** Generate important UI elements and store them in this **/\n      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n      _ui.$errorClassHandler = this._manageClassHandler();\n\n      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n      _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\n      _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n      _ui.lastValidationResult = [];\n      _ui.validationInformationVisible = false;\n\n      // Store it in this for later\n      this._ui = _ui;\n    },\n\n    // Determine which element will have `parsley-error` and `parsley-success` classes\n    _manageClassHandler: function () {\n      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n      if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length)\n        return $(this.options.classHandler);\n\n      // Class handled could also be determined by function given in Parsley options\n      var $handler = this.options.classHandler.call(this, this);\n\n      // If this function returned a valid existing DOM element, go for it\n      if ('undefined' !== typeof $handler && $handler.length)\n        return $handler;\n\n      return this._inputHolder();\n    },\n\n    _inputHolder: function() {\n      // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\n      if (!this.options.multiple || this.$element.is('select'))\n        return this.$element;\n\n      // But if multiple element (radio, checkbox), that would be their parent\n      return this.$element.parent();\n    },\n\n    _insertErrorWrapper: function () {\n      var $errorsContainer;\n\n      // Nothing to do if already inserted\n      if (0 !== this._ui.$errorsWrapper.parent().length)\n        return this._ui.$errorsWrapper.parent();\n\n      if ('string' === typeof this.options.errorsContainer) {\n        if ($(this.options.errorsContainer).length)\n          return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);\n        else\n          ParsleyUtils__default.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\n      } else if ('function' === typeof this.options.errorsContainer)\n        $errorsContainer = this.options.errorsContainer.call(this, this);\n\n      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\n        return $errorsContainer.append(this._ui.$errorsWrapper);\n\n      return this._inputHolder().after(this._ui.$errorsWrapper);\n    },\n\n    _actualizeTriggers: function () {\n      var $toBind = this._findRelated();\n      var trigger;\n\n      // Remove Parsley events already bound on this field\n      $toBind.off('.Parsley');\n      if (this._failedOnce)\n        $toBind.on(ParsleyUtils__default.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), () => {\n          this._validateIfNeeded();\n        });\n      else if (trigger = ParsleyUtils__default.namespaceEvents(this.options.trigger, 'Parsley')) {\n        $toBind.on(trigger, event => {\n          this._validateIfNeeded(event);\n        });\n      }\n    },\n\n    _validateIfNeeded: function (event) {\n      // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\n      // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n      if (event && /key|input/.test(event.type))\n        if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold)\n          return;\n\n      if (this.options.debounce) {\n        window.clearTimeout(this._debounced);\n        this._debounced = window.setTimeout(() => this.validate(), this.options.debounce);\n      } else\n        this.validate();\n    },\n\n    _resetUI: function () {\n      // Reset all event listeners\n      this._failedOnce = false;\n      this._actualizeTriggers();\n\n      // Nothing to do if UI never initialized for this field\n      if ('undefined' === typeof this._ui)\n        return;\n\n      // Reset all errors' li\n      this._ui.$errorsWrapper\n        .removeClass('filled')\n        .children()\n        .remove();\n\n      // Reset validation class\n      this._resetClass();\n\n      // Reset validation flags and last validation result\n      this._ui.lastValidationResult = [];\n      this._ui.validationInformationVisible = false;\n    },\n\n    _destroyUI: function () {\n      this._resetUI();\n\n      if ('undefined' !== typeof this._ui)\n        this._ui.$errorsWrapper.remove();\n\n      delete this._ui;\n    },\n\n    _successClass: function () {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\n    },\n    _errorClass: function () {\n      this._ui.validationInformationVisible = true;\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\n    },\n    _resetClass: function () {\n      this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\n    }\n  };\n\n  var ParsleyForm = function (element, domOptions, options) {\n    this.__class__ = 'ParsleyForm';\n\n    this.$element = $(element);\n    this.domOptions = domOptions;\n    this.options = options;\n    this.parent = window.Parsley;\n\n    this.fields = [];\n    this.validationResult = null;\n  };\n\n  var ParsleyForm__statusMapping = {pending: null, resolved: true, rejected: false};\n\n  ParsleyForm.prototype = {\n    onSubmitValidate: function (event) {\n      // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n      if (true === event.parsley)\n        return;\n\n      // If we didn't come here through a submit button, use the first one in the form\n      var $submitSource = this._$submitSource || this.$element.find(ParsleyUtils__default._SubmitSelector).first();\n      this._$submitSource = null;\n      this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\n      if ($submitSource.is('[formnovalidate]'))\n        return;\n\n      var promise = this.whenValidate({event});\n\n      if ('resolved' === promise.state() && false !== this._trigger('submit')) {\n        // All good, let event go through. We make this distinction because browsers\n        // differ in their handling of `submit` being called from inside a submit event [#1047]\n      } else {\n        // Rejected or pending: cancel this submit\n        event.stopImmediatePropagation();\n        event.preventDefault();\n        if ('pending' === promise.state())\n          promise.done(() => { this._submit($submitSource); });\n      }\n    },\n\n    onSubmitButton: function(event) {\n      this._$submitSource = $(event.currentTarget);\n    },\n    // internal\n    // _submit submits the form, this time without going through the validations.\n    // Care must be taken to \"fake\" the actual submit button being clicked.\n    _submit: function ($submitSource) {\n      if (false === this._trigger('submit'))\n        return;\n      // Add submit button's data\n      if ($submitSource) {\n        var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\n        if (0 === $synthetic.length)\n          $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\n        $synthetic.attr({\n          name: $submitSource.attr('name'),\n          value: $submitSource.attr('value')\n        });\n      }\n\n      this.$element.trigger($.extend($.Event('submit'), {parsley: true}));\n    },\n\n    // Performs validation on fields while triggering events.\n    // @returns `true` if all validations succeeds, `false`\n    // if a failure is immediately detected, or `null`\n    // if dependant on a promise.\n    // Consider using `whenValidate` instead.\n    validate: function (options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\n        var [group, force, event] = arguments;\n        options = {group, force, event};\n      }\n      return ParsleyForm__statusMapping[ this.whenValidate(options).state() ];\n    },\n\n    whenValidate: function ({group, force, event} = {}) {\n      this.submitEvent = event;\n      if (event) {\n        this.submitEvent = $.extend({}, event, {preventDefault: () => {\n          ParsleyUtils__default.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\n          this.validationResult = false;\n        }});\n      }\n      this.validationResult = true;\n\n      // fire validate event to eventually modify things before every validation\n      this._trigger('validate');\n\n      // Refresh form DOM options and form's fields that could have changed\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(() => {\n        return $.map(this.fields, field => field.whenValidate({force, group}));\n      });\n\n      return ParsleyUtils__default.all(promises)\n        .done(  () => { this._trigger('success'); })\n        .fail(  () => {\n          this.validationResult = false;\n          this.focus();\n          this._trigger('error');\n        })\n        .always(() => { this._trigger('validated'); })\n        .pipe(...this._pipeAccordingToValidationResult());\n    },\n\n    // Iterate over refreshed fields, and stop on first failure.\n    // Returns `true` if all fields are valid, `false` if a failure is detected\n    // or `null` if the result depends on an unresolved promise.\n    // Prefer using `whenValid` instead.\n    isValid: function (options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\n        var [group, force] = arguments;\n        options = {group, force};\n      }\n      return ParsleyForm__statusMapping[ this.whenValid(options).state() ];\n    },\n\n    // Iterate over refreshed fields and validate them.\n    // Returns a promise.\n    // A validation that immediately fails will interrupt the validations.\n    whenValid: function ({group, force} = {}) {\n      this._refreshFields();\n\n      var promises = this._withoutReactualizingFormOptions(() => {\n        return $.map(this.fields, field => field.whenValid({group, force}));\n      });\n      return ParsleyUtils__default.all(promises);\n    },\n\n    _refreshFields: function () {\n      return this.actualizeOptions()._bindFields();\n    },\n\n    _bindFields: function () {\n      var oldFields = this.fields;\n\n      this.fields = [];\n      this.fieldsMappedById = {};\n\n      this._withoutReactualizingFormOptions(() => {\n        this.$element\n        .find(this.options.inputs)\n        .not(this.options.excluded)\n        .each((_, element) => {\n          var fieldInstance = new window.Parsley.Factory(element, {}, this);\n\n          // Only add valid and not excluded `ParsleyField` and `ParsleyFieldMultiple` children\n          if (('ParsleyField' === fieldInstance.__class__ || 'ParsleyFieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded))\n            if ('undefined' === typeof this.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__]) {\n              this.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__] = fieldInstance;\n              this.fields.push(fieldInstance);\n            }\n        });\n\n        $.each(ParsleyUtils__default.difference(oldFields, this.fields), (_, field) => {\n          field._trigger('reset');\n        });\n      });\n      return this;\n    },\n\n    // Internal only.\n    // Looping on a form's fields to do validation or similar\n    // will trigger reactualizing options on all of them, which\n    // in turn will reactualize the form's options.\n    // To avoid calling actualizeOptions so many times on the form\n    // for nothing, _withoutReactualizingFormOptions temporarily disables\n    // the method actualizeOptions on this form while `fn` is called.\n    _withoutReactualizingFormOptions: function (fn) {\n      var oldActualizeOptions = this.actualizeOptions;\n      this.actualizeOptions = function () { return this; };\n      var result = fn();\n      this.actualizeOptions = oldActualizeOptions;\n      return result;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    // Returns true iff event is not interrupted and default not prevented.\n    _trigger: function (eventName) {\n      return this.trigger('form:' + eventName);\n    }\n\n  };\n\n  var ConstraintFactory = function (parsleyField, name, requirements, priority, isDomConstraint) {\n    if (!/ParsleyField/.test(parsleyField.__class__))\n      throw new Error('ParsleyField or ParsleyFieldMultiple instance expected');\n\n    var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n    var validator = new ParsleyValidator(validatorSpec);\n\n    $.extend(this, {\n      validator: validator,\n      name: name,\n      requirements: requirements,\n      priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n      isDomConstraint: true === isDomConstraint\n    });\n    this._parseRequirements(parsleyField.options);\n  };\n\n  var capitalize = function(str) {\n    var cap = str[0].toUpperCase();\n    return cap + str.slice(1);\n  };\n\n  ConstraintFactory.prototype = {\n    validate: function(value, instance) {\n      return this.validator.validate(value, ...this.requirementList, instance);\n    },\n\n    _parseRequirements: function(options) {\n      this.requirementList = this.validator.parseRequirements(this.requirements,\n        key => options[this.name + capitalize(key)]\n      );\n    }\n  };\n\n  var ParsleyField = function (field, domOptions, options, parsleyFormInstance) {\n    this.__class__ = 'ParsleyField';\n\n    this.$element = $(field);\n\n    // Set parent if we have one\n    if ('undefined' !== typeof parsleyFormInstance) {\n      this.parent = parsleyFormInstance;\n    }\n\n    this.options = options;\n    this.domOptions = domOptions;\n\n    // Initialize some properties\n    this.constraints = [];\n    this.constraintsByName = {};\n    this.validationResult = true;\n\n    // Bind constraints\n    this._bindConstraints();\n  };\n\n  var parsley_field__statusMapping = {pending: null, resolved: true, rejected: false};\n\n  ParsleyField.prototype = {\n    // # Public API\n    // Validate field and trigger some events for mainly `ParsleyUI`\n    // @returns `true`, an array of the validators that failed, or\n    // `null` if validation is not finished. Prefer using whenValidate\n    validate: function (options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\n        options = {options};\n      }\n      var promise = this.whenValidate(options);\n      if (!promise)  // If excluded with `group` option\n        return true;\n      switch (promise.state()) {\n        case 'pending': return null;\n        case 'resolved': return true;\n        case 'rejected': return this.validationResult;\n      }\n    },\n\n    // Validate field and trigger some events for mainly `ParsleyUI`\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if field is not in the given `group`.\n    whenValidate: function ({force, group} =  {}) {\n      // do not validate a field if not the same as given validation group\n      this.refreshConstraints();\n      if (group && !this._isInGroup(group))\n        return;\n\n      this.value = this.getValue();\n\n      // Field Validate event. `this.value` could be altered for custom needs\n      this._trigger('validate');\n\n      return this.whenValid({force, value: this.value, _refreshed: true})\n        .always(() => { this._reflowUI(); })\n        .done(() =>   { this._trigger('success'); })\n        .fail(() =>   { this._trigger('error'); })\n        .always(() => { this._trigger('validated'); })\n        .pipe(...this._pipeAccordingToValidationResult());\n    },\n\n    hasConstraints: function () {\n      return 0 !== this.constraints.length;\n    },\n\n    // An empty optional field does not need validation\n    needsValidation: function (value) {\n      if ('undefined' === typeof value)\n        value = this.getValue();\n\n      // If a field is empty and not required, it is valid\n      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n      if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\n        return false;\n\n      return true;\n    },\n\n    _isInGroup: function (group) {\n      if ($.isArray(this.options.group))\n        return -1 !== $.inArray(group, this.options.group);\n      return this.options.group === group;\n    },\n\n    // Just validate field. Do not trigger any event.\n    // Returns `true` iff all constraints pass, `false` if there are failures,\n    // or `null` if the result can not be determined yet (depends on a promise)\n    // See also `whenValid`.\n    isValid: function (options) {\n      if (arguments.length >= 1 && !$.isPlainObject(options)) {\n        ParsleyUtils__default.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\n        var [force, value] = arguments;\n        options = {force, value};\n      }\n      var promise = this.whenValid(options);\n      if (!promise) // Excluded via `group`\n        return true;\n      return parsley_field__statusMapping[promise.state()];\n    },\n\n    // Just validate field. Do not trigger any event.\n    // @returns a promise that succeeds only when all validations do\n    // or `undefined` if the field is not in the given `group`.\n    // The argument `force` will force validation of empty fields.\n    // If a `value` is given, it will be validated instead of the value of the input.\n    whenValid: function ({force = false, value, group, _refreshed} = {}) {\n      // Recompute options and rebind constraints to have latest changes\n      if (!_refreshed)\n        this.refreshConstraints();\n      // do not validate a field if not the same as given validation group\n      if (group && !this._isInGroup(group))\n        return;\n\n      this.validationResult = true;\n\n      // A field without constraint is valid\n      if (!this.hasConstraints())\n        return $.when();\n\n      // Value could be passed as argument, needed to add more power to 'field:validate'\n      if ('undefined' === typeof value || null === value)\n        value = this.getValue();\n\n      if (!this.needsValidation(value) && true !== force)\n        return $.when();\n\n      var groupedConstraints = this._getGroupedConstraints();\n      var promises = [];\n      $.each(groupedConstraints, (_, constraints) => {\n        // Process one group of constraints at a time, we validate the constraints\n        // and combine the promises together.\n        var promise = ParsleyUtils__default.all(\n          $.map(constraints, constraint => this._validateConstraint(value, constraint))\n        );\n        promises.push(promise);\n        if (promise.state() === 'rejected')\n          return false; // Interrupt processing if a group has already failed\n      });\n      return ParsleyUtils__default.all(promises);\n    },\n\n    // @returns a promise\n    _validateConstraint: function(value, constraint) {\n      var result = constraint.validate(value, this);\n      // Map false to a failed promise\n      if (false === result)\n        result = $.Deferred().reject();\n      // Make sure we return a promise and that we record failures\n      return ParsleyUtils__default.all([result]).fail(errorMessage => {\n        if (!(this.validationResult instanceof Array))\n          this.validationResult = [];\n        this.validationResult.push({\n          assert: constraint,\n          errorMessage: 'string' === typeof errorMessage && errorMessage\n        });\n      });\n    },\n\n    // @returns Parsley field computed value that could be overrided or configured in DOM\n    getValue: function () {\n      var value;\n\n      // Value could be overriden in DOM or with explicit options\n      if ('function' === typeof this.options.value)\n        value = this.options.value(this);\n      else if ('undefined' !== typeof this.options.value)\n        value = this.options.value;\n      else\n        value = this.$element.val();\n\n      // Handle wrong DOM or configurations\n      if ('undefined' === typeof value || null === value)\n        return '';\n\n      return this._handleWhitespace(value);\n    },\n\n    // Actualize options that could have change since previous validation\n    // Re-bind accordingly constraints (could be some new, removed or updated)\n    refreshConstraints: function () {\n      return this.actualizeOptions()._bindConstraints();\n    },\n\n    /**\n    * Add a new constraint to a field\n    *\n    * @param {String}   name\n    * @param {Mixed}    requirements      optional\n    * @param {Number}   priority          optional\n    * @param {Boolean}  isDomConstraint   optional\n    */\n    addConstraint: function (name, requirements, priority, isDomConstraint) {\n\n      if (window.Parsley._validatorRegistry.validators[name]) {\n        var constraint = new ConstraintFactory(this, name, requirements, priority, isDomConstraint);\n\n        // if constraint already exist, delete it and push new version\n        if ('undefined' !== this.constraintsByName[constraint.name])\n          this.removeConstraint(constraint.name);\n\n        this.constraints.push(constraint);\n        this.constraintsByName[constraint.name] = constraint;\n      }\n\n      return this;\n    },\n\n    // Remove a constraint\n    removeConstraint: function (name) {\n      for (var i = 0; i < this.constraints.length; i++)\n        if (name === this.constraints[i].name) {\n          this.constraints.splice(i, 1);\n          break;\n        }\n      delete this.constraintsByName[name];\n      return this;\n    },\n\n    // Update a constraint (Remove + re-add)\n    updateConstraint: function (name, parameters, priority) {\n      return this.removeConstraint(name)\n        .addConstraint(name, parameters, priority);\n    },\n\n    // # Internals\n\n    // Internal only.\n    // Bind constraints from config + options + DOM\n    _bindConstraints: function () {\n      var constraints = [];\n      var constraintsByName = {};\n\n      // clean all existing DOM constraints to only keep javascript user constraints\n      for (var i = 0; i < this.constraints.length; i++)\n        if (false === this.constraints[i].isDomConstraint) {\n          constraints.push(this.constraints[i]);\n          constraintsByName[this.constraints[i].name] = this.constraints[i];\n        }\n\n      this.constraints = constraints;\n      this.constraintsByName = constraintsByName;\n\n      // then re-add Parsley DOM-API constraints\n      for (var name in this.options)\n        this.addConstraint(name, this.options[name], undefined, true);\n\n      // finally, bind special HTML5 constraints\n      return this._bindHtml5Constraints();\n    },\n\n    // Internal only.\n    // Bind specific HTML5 constraints to be HTML5 compliant\n    _bindHtml5Constraints: function () {\n      // html5 required\n      if (this.$element.attr('required'))\n        this.addConstraint('required', true, undefined, true);\n\n      // html5 pattern\n      if ('string' === typeof this.$element.attr('pattern'))\n        this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n      // range\n      if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max'))\n        this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n      // HTML5 min\n      else if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('min'))\n        this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n      // HTML5 max\n      else if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('max'))\n        this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n\n      // length\n      if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength'))\n        this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n      // HTML5 minlength\n      else if ('undefined' !== typeof this.$element.attr('minlength'))\n        this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n      // HTML5 maxlength\n      else if ('undefined' !== typeof this.$element.attr('maxlength'))\n        this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n\n      // html5 types\n      var type = this.$element.attr('type');\n\n      if ('undefined' === typeof type)\n        return this;\n\n      // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n      if ('number' === type) {\n        return this.addConstraint('type', ['number', {\n          step: this.$element.attr('step') || '1',\n          base: this.$element.attr('min') || this.$element.attr('value')\n        }], undefined, true);\n      // Regular other HTML5 supported types\n      } else if (/^(email|url|range)$/i.test(type)) {\n        return this.addConstraint('type', type, undefined, true);\n      }\n      return this;\n    },\n\n    // Internal only.\n    // Field is required if have required constraint without `false` value\n    _isRequired: function () {\n      if ('undefined' === typeof this.constraintsByName.required)\n        return false;\n\n      return false !== this.constraintsByName.required.requirements;\n    },\n\n    // Internal only.\n    // Shortcut to trigger an event\n    _trigger: function (eventName) {\n      return this.trigger('field:' + eventName);\n    },\n\n    // Internal only\n    // Handles whitespace in a value\n    // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n    // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n    _handleWhitespace: function (value) {\n      if (true === this.options.trimValue)\n        ParsleyUtils__default.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n      if ('squish' === this.options.whitespace)\n        value = value.replace(/\\s{2,}/g, ' ');\n\n      if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\n        value = ParsleyUtils__default.trimString(value);\n\n      return value;\n    },\n\n    // Internal only.\n    // Returns the constraints, grouped by descending priority.\n    // The result is thus an array of arrays of constraints.\n    _getGroupedConstraints: function () {\n      if (false === this.options.priorityEnabled)\n        return [this.constraints];\n\n      var groupedConstraints = [];\n      var index = {};\n\n      // Create array unique of priorities\n      for (var i = 0; i < this.constraints.length; i++) {\n        var p = this.constraints[i].priority;\n        if (!index[p])\n          groupedConstraints.push(index[p] = []);\n        index[p].push(this.constraints[i]);\n      }\n      // Sort them by priority DESC\n      groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\n\n      return groupedConstraints;\n    }\n\n  };\n\n  var parsley_field = ParsleyField;\n\n  var ParsleyMultiple = function () {\n    this.__class__ = 'ParsleyFieldMultiple';\n  };\n\n  ParsleyMultiple.prototype = {\n    // Add new `$element` sibling for multiple field\n    addElement: function ($element) {\n      this.$elements.push($element);\n\n      return this;\n    },\n\n    // See `ParsleyField.refreshConstraints()`\n    refreshConstraints: function () {\n      var fieldConstraints;\n\n      this.constraints = [];\n\n      // Select multiple special treatment\n      if (this.$element.is('select')) {\n        this.actualizeOptions()._bindConstraints();\n\n        return this;\n      }\n\n      // Gather all constraints for each input in the multiple group\n      for (var i = 0; i < this.$elements.length; i++) {\n\n        // Check if element have not been dynamically removed since last binding\n        if (!$('html').has(this.$elements[i]).length) {\n          this.$elements.splice(i, 1);\n          continue;\n        }\n\n        fieldConstraints = this.$elements[i].data('ParsleyFieldMultiple').refreshConstraints().constraints;\n\n        for (var j = 0; j < fieldConstraints.length; j++)\n          this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n      }\n\n      return this;\n    },\n\n    // See `ParsleyField.getValue()`\n    getValue: function () {\n      // Value could be overriden in DOM\n      if ('function' === typeof this.options.value)\n        return this.options.value(this);\n      else if ('undefined' !== typeof this.options.value)\n        return this.options.value;\n\n      // Radio input case\n      if (this.$element.is('input[type=radio]'))\n        return this._findRelated().filter(':checked').val() || '';\n\n      // checkbox input case\n      if (this.$element.is('input[type=checkbox]')) {\n        var values = [];\n\n        this._findRelated().filter(':checked').each(function () {\n          values.push($(this).val());\n        });\n\n        return values;\n      }\n\n      // Select multiple case\n      if (this.$element.is('select') && null === this.$element.val())\n        return [];\n\n      // Default case that should never happen\n      return this.$element.val();\n    },\n\n    _init: function () {\n      this.$elements = [this.$element];\n\n      return this;\n    }\n  };\n\n  var ParsleyFactory = function (element, options, parsleyFormInstance) {\n    this.$element = $(element);\n\n    // If the element has already been bound, returns its saved Parsley instance\n    var savedparsleyFormInstance = this.$element.data('Parsley');\n    if (savedparsleyFormInstance) {\n\n      // If the saved instance has been bound without a ParsleyForm parent and there is one given in this call, add it\n      if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n        savedparsleyFormInstance.parent = parsleyFormInstance;\n        savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n      }\n\n      if ('object' === typeof options) {\n        $.extend(savedparsleyFormInstance.options, options);\n      }\n\n      return savedparsleyFormInstance;\n    }\n\n    // Parsley must be instantiated with a DOM element or jQuery $element\n    if (!this.$element.length)\n      throw new Error('You must bind Parsley on an existing element.');\n\n    if ('undefined' !== typeof parsleyFormInstance && 'ParsleyForm' !== parsleyFormInstance.__class__)\n      throw new Error('Parent instance must be a ParsleyForm instance');\n\n    this.parent = parsleyFormInstance || window.Parsley;\n    return this.init(options);\n  };\n\n  ParsleyFactory.prototype = {\n    init: function (options) {\n      this.__class__ = 'Parsley';\n      this.__version__ = '2.6.1';\n      this.__id__ = ParsleyUtils__default.generateID();\n\n      // Pre-compute options\n      this._resetOptions(options);\n\n      // A ParsleyForm instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n      if (this.$element.is('form') || (ParsleyUtils__default.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\n        return this.bind('parsleyForm');\n\n      // Every other element is bound as a `ParsleyField` or `ParsleyFieldMultiple`\n      return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n    },\n\n    isMultiple: function () {\n      return (this.$element.is('input[type=radio], input[type=checkbox]')) || (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple'));\n    },\n\n    // Multiples fields are a real nightmare :(\n    // Maybe some refactoring would be appreciated here...\n    handleMultiple: function () {\n      var name;\n      var multiple;\n      var parsleyMultipleInstance;\n\n      // Handle multiple name\n      if (this.options.multiple)\n        ; // We already have our 'multiple' identifier\n      else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length)\n        this.options.multiple = name = this.$element.attr('name');\n      else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length)\n        this.options.multiple = this.$element.attr('id');\n\n      // Special select multiple input\n      if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n        this.options.multiple = this.options.multiple || this.__id__;\n        return this.bind('parsleyFieldMultiple');\n\n      // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n      } else if (!this.options.multiple) {\n        ParsleyUtils__default.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n        return this;\n      }\n\n      // Remove special chars\n      this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n      if ('undefined' !== typeof name) {\n        $('input[name=\"' + name + '\"]').each((i, input) => {\n          if ($(input).is('input[type=radio], input[type=checkbox]'))\n            $(input).attr(this.options.namespace + 'multiple', this.options.multiple);\n        });\n      }\n\n      // Check here if we don't already have a related multiple instance saved\n      var $previouslyRelated = this._findRelated();\n      for (var i = 0; i < $previouslyRelated.length; i++) {\n        parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n        if ('undefined' !== typeof parsleyMultipleInstance) {\n\n          if (!this.$element.data('ParsleyFieldMultiple')) {\n            parsleyMultipleInstance.addElement(this.$element);\n          }\n\n          break;\n        }\n      }\n\n      // Create a secret ParsleyField instance for every multiple field. It will be stored in `data('ParsleyFieldMultiple')`\n      // And will be useful later to access classic `ParsleyField` stuff while being in a `ParsleyFieldMultiple` instance\n      this.bind('parsleyField', true);\n\n      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n    },\n\n    // Return proper `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`\n    bind: function (type, doNotStore) {\n      var parsleyInstance;\n\n      switch (type) {\n        case 'parsleyForm':\n          parsleyInstance = $.extend(\n            new ParsleyForm(this.$element, this.domOptions, this.options),\n            new ParsleyAbstract(),\n            window.ParsleyExtend\n          )._bindFields();\n          break;\n        case 'parsleyField':\n          parsleyInstance = $.extend(\n            new parsley_field(this.$element, this.domOptions, this.options, this.parent),\n            new ParsleyAbstract(),\n            window.ParsleyExtend\n          );\n          break;\n        case 'parsleyFieldMultiple':\n          parsleyInstance = $.extend(\n            new parsley_field(this.$element, this.domOptions, this.options, this.parent),\n            new ParsleyMultiple(),\n            new ParsleyAbstract(),\n            window.ParsleyExtend\n          )._init();\n          break;\n        default:\n          throw new Error(type + 'is not a supported Parsley type');\n      }\n\n      if (this.options.multiple)\n        ParsleyUtils__default.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n      if ('undefined' !== typeof doNotStore) {\n        this.$element.data('ParsleyFieldMultiple', parsleyInstance);\n\n        return parsleyInstance;\n      }\n\n      // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n      this.$element.data('Parsley', parsleyInstance);\n\n      // Tell the world we have a new ParsleyForm or ParsleyField instance!\n      parsleyInstance._actualizeTriggers();\n      parsleyInstance._trigger('init');\n\n      return parsleyInstance;\n    }\n  };\n\n  var vernums = $.fn.jquery.split('.');\n  if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\n    throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\n  }\n  if (!vernums.forEach) {\n    ParsleyUtils__default.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\n  }\n  // Inherit `on`, `off` & `trigger` to Parsley:\n  var Parsley = $.extend(new ParsleyAbstract(), {\n      $element: $(document),\n      actualizeOptions: null,\n      _resetOptions: null,\n      Factory: ParsleyFactory,\n      version: '2.6.1'\n    });\n\n  // Supplement ParsleyField and Form with ParsleyAbstract\n  // This way, the constructors will have access to those methods\n  $.extend(parsley_field.prototype, ParsleyUI.Field, ParsleyAbstract.prototype);\n  $.extend(ParsleyForm.prototype, ParsleyUI.Form, ParsleyAbstract.prototype);\n  // Inherit actualizeOptions and _resetOptions:\n  $.extend(ParsleyFactory.prototype, ParsleyAbstract.prototype);\n\n  // ### jQuery API\n  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n  $.fn.parsley = $.fn.psly = function (options) {\n    if (this.length > 1) {\n      var instances = [];\n\n      this.each(function () {\n        instances.push($(this).parsley(options));\n      });\n\n      return instances;\n    }\n\n    // Return undefined if applied to non existing DOM element\n    if (!$(this).length) {\n      ParsleyUtils__default.warn('You must bind Parsley on an existing element.');\n\n      return;\n    }\n\n    return new ParsleyFactory(this, options);\n  };\n\n  // ### ParsleyField and ParsleyForm extension\n  // Ensure the extension is now defined if it wasn't previously\n  if ('undefined' === typeof window.ParsleyExtend)\n    window.ParsleyExtend = {};\n\n  // ### Parsley config\n  // Inherit from ParsleyDefault, and copy over any existing values\n  Parsley.options = $.extend(ParsleyUtils__default.objectCreate(ParsleyDefaults), window.ParsleyConfig);\n  window.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n  // ### Globals\n  window.Parsley = window.psly = Parsley;\n  window.ParsleyUtils = ParsleyUtils__default;\n\n  // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\n  var registry = window.Parsley._validatorRegistry = new ParsleyValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\n  window.ParsleyValidator = {};\n  $.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n    window.Parsley[method] = $.proxy(registry, method);\n    window.ParsleyValidator[method] = function () {\n      ParsleyUtils__default.warnOnce(`Accessing the method '${method}' through ParsleyValidator is deprecated. Simply call 'window.Parsley.${method}(...)'`);\n      return window.Parsley[method](...arguments);\n    };\n  });\n\n  // ### ParsleyUI\n  // Deprecated global object\n  window.Parsley.UI = ParsleyUI;\n  window.ParsleyUI = {\n    removeError: function (instance, name, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      ParsleyUtils__default.warnOnce(`Accessing ParsleyUI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\n      return instance.removeError(name, {updateClass});\n    },\n    getErrorsMessages: function (instance) {\n      ParsleyUtils__default.warnOnce(`Accessing ParsleyUI is deprecated. Call 'getErrorsMessages' on the instance directly.`);\n      return instance.getErrorsMessages();\n    }\n  };\n  $.each('addError updateError'.split(' '), function (i, method) {\n    window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\n      var updateClass = true !== doNotUpdateClass;\n      ParsleyUtils__default.warnOnce(`Accessing ParsleyUI is deprecated. Call '${method}' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\n      return instance[method](name, {message, assert, updateClass});\n    };\n  });\n\n  // ### PARSLEY auto-binding\n  // Prevent it by setting `ParsleyConfig.autoBind` to `false`\n  if (false !== window.ParsleyConfig.autoBind) {\n    $(function () {\n      // Works only on `data-parsley-validate`.\n      if ($('[data-parsley-validate]').length)\n        $('[data-parsley-validate]').parsley();\n    });\n  }\n\n  var o = $({});\n  var deprecated = function () {\n    ParsleyUtils__default.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n  };\n\n  // Returns an event handler that calls `fn` with the arguments it expects\n  function adapt(fn, context) {\n    // Store to allow unbinding\n    if (!fn.parsleyAdaptedCallback) {\n      fn.parsleyAdaptedCallback = function () {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args.unshift(this);\n        fn.apply(context || o, args);\n      };\n    }\n    return fn.parsleyAdaptedCallback;\n  }\n\n  var eventPrefix = 'parsley:';\n  // Converts 'parsley:form:validate' into 'form:validate'\n  function eventName(name) {\n    if (name.lastIndexOf(eventPrefix, 0) === 0)\n      return name.substr(eventPrefix.length);\n    return name;\n  }\n\n  // $.listen is deprecated. Use Parsley.on instead.\n  $.listen = function (name, callback) {\n    var context;\n    deprecated();\n    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n      context = arguments[1];\n      callback = arguments[2];\n    }\n\n    if ('function' !== typeof callback)\n      throw new Error('Wrong parameters');\n\n    window.Parsley.on(eventName(name), adapt(callback, context));\n  };\n\n  $.listenTo = function (instance, name, fn) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof ParsleyForm))\n      throw new Error('Must give Parsley instance');\n\n    if ('string' !== typeof name || 'function' !== typeof fn)\n      throw new Error('Wrong parameters');\n\n    instance.on(eventName(name), adapt(fn));\n  };\n\n  $.unsubscribe = function (name, fn) {\n    deprecated();\n    if ('string' !== typeof name || 'function' !== typeof fn)\n      throw new Error('Wrong arguments');\n    window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n  };\n\n  $.unsubscribeTo = function (instance, name) {\n    deprecated();\n    if (!(instance instanceof parsley_field) && !(instance instanceof ParsleyForm))\n      throw new Error('Must give Parsley instance');\n    instance.off(eventName(name));\n  };\n\n  $.unsubscribeAll = function (name) {\n    deprecated();\n    window.Parsley.off(eventName(name));\n    $('form,input,textarea,select').each(function () {\n      var instance = $(this).data('Parsley');\n      if (instance) {\n        instance.off(eventName(name));\n      }\n    });\n  };\n\n  // $.emit is deprecated. Use jQuery events instead.\n  $.emit = function (name, instance) {\n    deprecated();\n    var instanceGiven = (instance instanceof parsley_field) || (instance instanceof ParsleyForm);\n    var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n    args.unshift(eventName(name));\n    if (!instanceGiven) {\n      instance = window.Parsley;\n    }\n    instance.trigger(...args);\n  };\n\n  var pubsub = {};\n\n  $.extend(true, Parsley, {\n    asyncValidators: {\n      'default': {\n        fn: function (xhr) {\n          // By default, only status 2xx are deemed successful.\n          // Note: we use status instead of state() because responses with status 200\n          // but invalid messages (e.g. an empty body for content type set to JSON) will\n          // result in state() === 'rejected'.\n          return xhr.status >= 200 && xhr.status < 300;\n        },\n        url: false\n      },\n      reverse: {\n        fn: function (xhr) {\n          // If reverse option is set, a failing ajax request is considered successful\n          return xhr.status < 200 || xhr.status >= 300;\n        },\n        url: false\n      }\n    },\n\n    addAsyncValidator: function (name, fn, url, options) {\n      Parsley.asyncValidators[name] = {\n        fn: fn,\n        url: url || false,\n        options: options || {}\n      };\n\n      return this;\n    }\n\n  });\n\n  Parsley.addValidator('remote', {\n    requirementType: {\n      '': 'string',\n      'validator': 'string',\n      'reverse': 'boolean',\n      'options': 'object'\n    },\n\n    validateString: function (value, url, options, instance) {\n      var data = {};\n      var ajaxOptions;\n      var csr;\n      var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\n\n      if ('undefined' === typeof Parsley.asyncValidators[validator])\n        throw new Error('Calling an undefined async validator: `' + validator + '`');\n\n      url = Parsley.asyncValidators[validator].url || url;\n\n      // Fill current value\n      if (url.indexOf('{value}') > -1) {\n        url = url.replace('{value}', encodeURIComponent(value));\n      } else {\n        data[instance.$element.attr('name') || instance.$element.attr('id')] = value;\n      }\n\n      // Merge options passed in from the function with the ones in the attribute\n      var remoteOptions = $.extend(true, options.options || {} , Parsley.asyncValidators[validator].options);\n\n      // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\n      ajaxOptions = $.extend(true, {}, {\n        url: url,\n        data: data,\n        type: 'GET'\n      }, remoteOptions);\n\n      // Generate store key based on ajax options\n      instance.trigger('field:ajaxoptions', instance, ajaxOptions);\n\n      csr = $.param(ajaxOptions);\n\n      // Initialise querry cache\n      if ('undefined' === typeof Parsley._remoteCache)\n        Parsley._remoteCache = {};\n\n      // Try to retrieve stored xhr\n      var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\n\n      var handleXhr = function () {\n        var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\n        if (!result) // Map falsy results to rejected promise\n          result = $.Deferred().reject();\n        return $.when(result);\n      };\n\n      return xhr.then(handleXhr, handleXhr);\n    },\n\n    priority: -1\n  });\n\n  Parsley.on('form:submit', function () {\n    Parsley._remoteCache = {};\n  });\n\n  window.ParsleyExtend.addAsyncValidator = function () {\n    ParsleyUtils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\n    return Parsley.addAsyncValidator(...arguments);\n  };\n\n  // This is included with the Parsley library itself,\n  // thus there is no use in adding it to your project.\n  Parsley.addMessages('en', {\n    defaultMessage: \"This value seems to be invalid.\",\n    type: {\n      email:        \"This value should be a valid email.\",\n      url:          \"This value should be a valid url.\",\n      number:       \"This value should be a valid number.\",\n      integer:      \"This value should be a valid integer.\",\n      digits:       \"This value should be digits.\",\n      alphanum:     \"This value should be alphanumeric.\"\n    },\n    notblank:       \"This value should not be blank.\",\n    required:       \"This value is required.\",\n    pattern:        \"This value seems to be invalid.\",\n    min:            \"This value should be greater than or equal to %s.\",\n    max:            \"This value should be lower than or equal to %s.\",\n    range:          \"This value should be between %s and %s.\",\n    minlength:      \"This value is too short. It should have %s characters or more.\",\n    maxlength:      \"This value is too long. It should have %s characters or fewer.\",\n    length:         \"This value length is invalid. It should be between %s and %s characters long.\",\n    mincheck:       \"You must select at least %s choices.\",\n    maxcheck:       \"You must select %s choices or fewer.\",\n    check:          \"You must select between %s and %s choices.\",\n    equalto:        \"This value should be the same.\"\n  });\n\n  Parsley.setLocale('en');\n\n  /**\n   * inputevent - Alleviate browser bugs for input events\n   * https://github.com/marcandre/inputevent\n   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\n   * @author Marc-Andre Lafortune <github@marc-andre.ca>\n   * @license MIT\n   */\n\n  function InputEvent() {\n    let globals = window || global;\n\n    // Slightly odd way construct our object. This way methods are force bound.\n    // Used to test for duplicate library.\n    $.extend(this, {\n\n      // For browsers that do not support isTrusted, assumes event is native.\n      isNativeEvent: evt => {\n        return evt.originalEvent && evt.originalEvent.isTrusted !== false;\n      },\n\n      fakeInputEvent: evt => {\n        if (this.isNativeEvent(evt)) {\n          $(evt.target).trigger('input');\n        }\n      },\n\n      misbehaves: evt => {\n        if (this.isNativeEvent(evt)) {\n          this.behavesOk(evt);\n          $(document)\n            .on('change.inputevent', evt.data.selector, this.fakeInputEvent);\n          this.fakeInputEvent(evt);\n        }\n      },\n\n      behavesOk: evt => {\n        if (this.isNativeEvent(evt)) {\n          $(document) // Simply unbinds the testing handler\n            .off('input.inputevent', evt.data.selector, this.behavesOk)\n            .off('change.inputevent', evt.data.selector, this.misbehaves);\n        }\n      },\n\n      // Bind the testing handlers\n      install: () => {\n        if (globals.inputEventPatched) {\n          return;\n        }\n        globals.inputEventPatched = '0.0.3';\n        for (let selector of ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]']) {\n          $(document)\n            .on('input.inputevent', selector, {selector}, this.behavesOk)\n            .on('change.inputevent', selector, {selector}, this.misbehaves);\n        }\n      },\n\n      uninstall: () => {\n        delete globals.inputEventPatched;\n        $(document).off('.inputevent');\n      }\n\n    });\n  };\n\n  var inputevent = new InputEvent();\n\n  inputevent.install();\n\n  var parsley = Parsley;\n\n  return parsley;\n\n}));\n","import $ from 'jquery';\nimport ParsleyField from './field';\nimport ParsleyForm from './form';\nimport ParsleyUtils from './utils';\n\nvar o = $({});\nvar deprecated = function () {\n  ParsleyUtils.warnOnce(\"Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley\");\n};\n\n// Returns an event handler that calls `fn` with the arguments it expects\nfunction adapt(fn, context) {\n  // Store to allow unbinding\n  if (!fn.parsleyAdaptedCallback) {\n    fn.parsleyAdaptedCallback = function () {\n      var args = Array.prototype.slice.call(arguments, 0);\n      args.unshift(this);\n      fn.apply(context || o, args);\n    };\n  }\n  return fn.parsleyAdaptedCallback;\n}\n\nvar eventPrefix = 'parsley:';\n// Converts 'parsley:form:validate' into 'form:validate'\nfunction eventName(name) {\n  if (name.lastIndexOf(eventPrefix, 0) === 0)\n    return name.substr(eventPrefix.length);\n  return name;\n}\n\n// $.listen is deprecated. Use Parsley.on instead.\n$.listen = function (name, callback) {\n  var context;\n  deprecated();\n  if ('object' === typeof arguments[1] && 'function' === typeof arguments[2]) {\n    context = arguments[1];\n    callback = arguments[2];\n  }\n\n  if ('function' !== typeof callback)\n    throw new Error('Wrong parameters');\n\n  window.Parsley.on(eventName(name), adapt(callback, context));\n};\n\n$.listenTo = function (instance, name, fn) {\n  deprecated();\n  if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))\n    throw new Error('Must give Parsley instance');\n\n  if ('string' !== typeof name || 'function' !== typeof fn)\n    throw new Error('Wrong parameters');\n\n  instance.on(eventName(name), adapt(fn));\n};\n\n$.unsubscribe = function (name, fn) {\n  deprecated();\n  if ('string' !== typeof name || 'function' !== typeof fn)\n    throw new Error('Wrong arguments');\n  window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);\n};\n\n$.unsubscribeTo = function (instance, name) {\n  deprecated();\n  if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))\n    throw new Error('Must give Parsley instance');\n  instance.off(eventName(name));\n};\n\n$.unsubscribeAll = function (name) {\n  deprecated();\n  window.Parsley.off(eventName(name));\n  $('form,input,textarea,select').each(function () {\n    var instance = $(this).data('Parsley');\n    if (instance) {\n      instance.off(eventName(name));\n    }\n  });\n};\n\n// $.emit is deprecated. Use jQuery events instead.\n$.emit = function (name, instance) {\n  deprecated();\n  var instanceGiven = (instance instanceof ParsleyField) || (instance instanceof ParsleyForm);\n  var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);\n  args.unshift(eventName(name));\n  if (!instanceGiven) {\n    instance = window.Parsley;\n  }\n  instance.trigger(...args);\n};\n\nexport default {};\n","/**\n * inputevent - Alleviate browser bugs for input events\n * https://github.com/marcandre/inputevent\n * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)\n * @author Marc-Andre Lafortune <github@marc-andre.ca>\n * @license MIT\n */\n\nimport $ from 'jquery';\n\nfunction InputEvent() {\n  let globals = window || global;\n\n  // Slightly odd way construct our object. This way methods are force bound.\n  // Used to test for duplicate library.\n  $.extend(this, {\n\n    // For browsers that do not support isTrusted, assumes event is native.\n    isNativeEvent: evt => {\n      return evt.originalEvent && evt.originalEvent.isTrusted !== false;\n    },\n\n    fakeInputEvent: evt => {\n      if (this.isNativeEvent(evt)) {\n        $(evt.target).trigger('input');\n      }\n    },\n\n    misbehaves: evt => {\n      if (this.isNativeEvent(evt)) {\n        this.behavesOk(evt);\n        $(document)\n          .on('change.inputevent', evt.data.selector, this.fakeInputEvent);\n        this.fakeInputEvent(evt);\n      }\n    },\n\n    behavesOk: evt => {\n      if (this.isNativeEvent(evt)) {\n        $(document) // Simply unbinds the testing handler\n          .off('input.inputevent', evt.data.selector, this.behavesOk)\n          .off('change.inputevent', evt.data.selector, this.misbehaves);\n      }\n    },\n\n    // Bind the testing handlers\n    install: () => {\n      if (globals.inputEventPatched) {\n        return;\n      }\n      globals.inputEventPatched = '0.0.3';\n      for (let selector of ['select', 'input[type=\"checkbox\"]', 'input[type=\"radio\"]', 'input[type=\"file\"]']) {\n        $(document)\n          .on('input.inputevent', selector, {selector}, this.behavesOk)\n          .on('change.inputevent', selector, {selector}, this.misbehaves);\n      }\n    },\n\n    uninstall: () => {\n      delete globals.inputEventPatched;\n      $(document).off('.inputevent');\n    }\n\n  });\n};\n\nexport default new InputEvent();\n","import $ from 'jquery';\n\nvar globalID = 1;\nvar pastWarnings = {};\n\nvar ParsleyUtils = {\n  // Parsley DOM-API\n  // returns object from dom attributes and values\n  attr: function ($element, namespace, obj) {\n    var i;\n    var attribute;\n    var attributes;\n    var regex = new RegExp('^' + namespace, 'i');\n\n    if ('undefined' === typeof obj)\n      obj = {};\n    else {\n      // Clear all own properties. This won't affect prototype's values\n      for (i in obj) {\n        if (obj.hasOwnProperty(i))\n          delete obj[i];\n      }\n    }\n\n    if ('undefined' === typeof $element || 'undefined' === typeof $element[0])\n      return obj;\n\n    attributes = $element[0].attributes;\n    for (i = attributes.length; i--; ) {\n      attribute = attributes[i];\n\n      if (attribute && attribute.specified && regex.test(attribute.name)) {\n        obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);\n      }\n    }\n\n    return obj;\n  },\n\n  checkAttr: function ($element, namespace, checkAttr) {\n    return $element.is('[' + namespace + checkAttr + ']');\n  },\n\n  setAttr: function ($element, namespace, attr, value) {\n    $element[0].setAttribute(this.dasherize(namespace + attr), String(value));\n  },\n\n  generateID: function () {\n    return '' + globalID++;\n  },\n\n  /** Third party functions **/\n  // Zepto deserialize function\n  deserializeValue: function (value) {\n    var num;\n\n    try {\n      return value ?\n        value == \"true\" ||\n        (value == \"false\" ? false :\n        value == \"null\" ? null :\n        !isNaN(num = Number(value)) ? num :\n        /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n        value)\n        : value;\n    } catch (e) { return value; }\n  },\n\n  // Zepto camelize function\n  camelize: function (str) {\n    return str.replace(/-+(.)?/g, function (match, chr) {\n      return chr ? chr.toUpperCase() : '';\n    });\n  },\n\n  // Zepto dasherize function\n  dasherize: function (str) {\n    return str.replace(/::/g, '/')\n      .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n      .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n      .replace(/_/g, '-')\n      .toLowerCase();\n  },\n\n  warn: function () {\n    if (window.console && 'function' === typeof window.console.warn)\n      window.console.warn(...arguments);\n  },\n\n  warnOnce: function(msg) {\n    if (!pastWarnings[msg]) {\n      pastWarnings[msg] = true;\n      this.warn(...arguments);\n    }\n  },\n\n  _resetWarnings: function () {\n    pastWarnings = {};\n  },\n\n  trimString: function(string) {\n    return string.replace(/^\\s+|\\s+$/g, '');\n  },\n\n  namespaceEvents: function(events, namespace) {\n    events = this.trimString(events || '').split(/\\s+/);\n    if (!events[0])\n      return '';\n    return $.map(events, evt => `${evt}.${namespace}`).join(' ');\n  },\n\n  difference: function(array, remove) {\n    // This is O(N^2), should be optimized\n    let result = [];\n    $.each(array, (_, elem) => {\n      if (remove.indexOf(elem) == -1)\n        result.push(elem);\n    });\n    return result;\n  },\n\n  // Alter-ego to native Promise.all, but for jQuery\n  all: function(promises) {\n    // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements\n    return $.when(...promises, 42, 42);\n  },\n\n  // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill\n  objectCreate: Object.create || (function () {\n    var Object = function () {};\n    return function (prototype) {\n      if (arguments.length > 1) {\n        throw Error('Second argument not supported');\n      }\n      if (typeof prototype != 'object') {\n        throw TypeError('Argument must be an object');\n      }\n      Object.prototype = prototype;\n      var result = new Object();\n      Object.prototype = null;\n      return result;\n    };\n  })(),\n\n  _SubmitSelector: 'input[type=\"submit\"], button:submit'\n};\n\nexport default ParsleyUtils;\n","// All these options could be overriden and specified directly in DOM using\n// `data-parsley-` default DOM-API\n// eg: `inputs` can be set in DOM using `data-parsley-inputs=\"input, textarea\"`\n// eg: `data-parsley-stop-on-first-failing-constraint=\"false\"`\n\nvar ParsleyDefaults = {\n  // ### General\n\n  // Default data-namespace for DOM API\n  namespace: 'data-parsley-',\n\n  // Supported inputs by default\n  inputs: 'input, textarea, select',\n\n  // Excluded inputs by default\n  excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',\n\n  // Stop validating field on highest priority failing constraint\n  priorityEnabled: true,\n\n  // ### Field only\n\n  // identifier used to group together inputs (e.g. radio buttons...)\n  multiple: null,\n\n  // identifier (or array of identifiers) used to validate only a select group of inputs\n  group: null,\n\n  // ### UI\n  // Enable\\Disable error messages\n  uiEnabled: true,\n\n  // Key events threshold before validation\n  validationThreshold: 3,\n\n  // Focused field on form validation error. 'first'|'last'|'none'\n  focus: 'first',\n\n  // event(s) that will trigger validation before first failure. eg: `input`...\n  trigger: false,\n\n  // event(s) that will trigger validation after first failure.\n  triggerAfterFailure: 'input',\n\n  // Class that would be added on every failing validation Parsley field\n  errorClass: 'parsley-error',\n\n  // Same for success validation\n  successClass: 'parsley-success',\n\n  // Return the `$element` that will receive these above success or error classes\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\n  classHandler: function (ParsleyField) {},\n\n  // Return the `$element` where errors will be appended\n  // Could also be (and given directly from DOM) a valid selector like `'#div'`\n  errorsContainer: function (ParsleyField) {},\n\n  // ul elem that would receive errors' list\n  errorsWrapper: '<ul class=\"parsley-errors-list\"></ul>',\n\n  // li elem that would receive error message\n  errorTemplate: '<li></li>'\n};\n\nexport default ParsleyDefaults;\n","import $ from 'jquery';\nimport ParsleyUtils from './utils';\n\nvar ParsleyAbstract = function () {\n  this.__id__ = ParsleyUtils.generateID();\n};\n\nParsleyAbstract.prototype = {\n  asyncSupport: true, // Deprecated\n\n  _pipeAccordingToValidationResult: function () {\n    var pipe = () => {\n      var r = $.Deferred();\n      if (true !== this.validationResult)\n        r.reject();\n      return r.resolve().promise();\n    };\n    return [pipe, pipe];\n  },\n\n  actualizeOptions: function () {\n    ParsleyUtils.attr(this.$element, this.options.namespace, this.domOptions);\n    if (this.parent && this.parent.actualizeOptions)\n      this.parent.actualizeOptions();\n    return this;\n  },\n\n  _resetOptions: function (initOptions) {\n    this.domOptions = ParsleyUtils.objectCreate(this.parent.options);\n    this.options = ParsleyUtils.objectCreate(this.domOptions);\n    // Shallow copy of ownProperties of initOptions:\n    for (var i in initOptions) {\n      if (initOptions.hasOwnProperty(i))\n        this.options[i] = initOptions[i];\n    }\n    this.actualizeOptions();\n  },\n\n  _listeners: null,\n\n  // Register a callback for the given event name\n  // Callback is called with context as the first argument and the `this`\n  // The context is the current parsley instance, or window.Parsley if global\n  // A return value of `false` will interrupt the calls\n  on: function (name, fn) {\n    this._listeners = this._listeners || {};\n    var queue = this._listeners[name] = this._listeners[name] || [];\n    queue.push(fn);\n\n    return this;\n  },\n\n  // Deprecated. Use `on` instead\n  subscribe: function(name, fn) {\n    $.listenTo(this, name.toLowerCase(), fn);\n  },\n\n  // Unregister a callback (or all if none is given) for the given event name\n  off: function (name, fn) {\n    var queue = this._listeners && this._listeners[name];\n    if (queue) {\n      if (!fn) {\n        delete this._listeners[name];\n      } else {\n        for (var i = queue.length; i--; )\n          if (queue[i] === fn)\n            queue.splice(i, 1);\n      }\n    }\n    return this;\n  },\n\n  // Deprecated. Use `off`\n  unsubscribe: function(name, fn) {\n    $.unsubscribeTo(this, name.toLowerCase());\n  },\n\n  // Trigger an event of the given name\n  // A return value of `false` interrupts the callback chain\n  // Returns false if execution was interrupted\n  trigger: function (name, target, extraArg) {\n    target = target || this;\n    var queue = this._listeners && this._listeners[name];\n    var result;\n    var parentResult;\n    if (queue) {\n      for (var i = queue.length; i--; ) {\n        result = queue[i].call(target, target, extraArg);\n        if (result === false) return result;\n      }\n    }\n    if (this.parent) {\n      return this.parent.trigger(name, target, extraArg);\n    }\n    return true;\n  },\n\n  // Reset UI\n  reset: function () {\n    // Field case: just emit a reset event for UI\n    if ('ParsleyForm' !== this.__class__) {\n      this._resetUI();\n      return this._trigger('reset');\n    }\n\n    // Form case: emit a reset event for each field\n    for (var i = 0; i < this.fields.length; i++)\n      this.fields[i].reset();\n\n    this._trigger('reset');\n  },\n\n  // Destroy Parsley instance (+ UI)\n  destroy: function () {\n    // Field case: emit destroy event to clean UI and then destroy stored instance\n    this._destroyUI();\n    if ('ParsleyForm' !== this.__class__) {\n      this.$element.removeData('Parsley');\n      this.$element.removeData('ParsleyFieldMultiple');\n      this._trigger('destroy');\n\n      return;\n    }\n\n    // Form case: destroy all its fields and then destroy stored instance\n    for (var i = 0; i < this.fields.length; i++)\n      this.fields[i].destroy();\n\n    this.$element.removeData('Parsley');\n    this._trigger('destroy');\n  },\n\n  asyncIsValid: function (group, force) {\n    ParsleyUtils.warnOnce(\"asyncIsValid is deprecated; please use whenValid instead\");\n    return this.whenValid({group, force});\n  },\n\n  _findRelated: function () {\n    return this.options.multiple ?\n      this.parent.$element.find(`[${this.options.namespace}multiple=\"${this.options.multiple}\"]`)\n    : this.$element;\n  }\n};\n\nexport default ParsleyAbstract;\n","import $ from 'jquery';\nimport ParsleyUtils from './utils';\n\nvar requirementConverters = {\n  string: function(string) {\n    return string;\n  },\n  integer: function(string) {\n    if (isNaN(string))\n      throw 'Requirement is not an integer: \"' + string + '\"';\n    return parseInt(string, 10);\n  },\n  number: function(string) {\n    if (isNaN(string))\n      throw 'Requirement is not a number: \"' + string + '\"';\n    return parseFloat(string);\n  },\n  reference: function(string) { // Unused for now\n    var result = $(string);\n    if (result.length === 0)\n      throw 'No such reference: \"' + string + '\"';\n    return result;\n  },\n  boolean: function(string) {\n    return string !== 'false';\n  },\n  object: function(string) {\n    return ParsleyUtils.deserializeValue(string);\n  },\n  regexp: function(regexp) {\n    var flags = '';\n\n    // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern\n    if (/^\\/.*\\/(?:[gimy]*)$/.test(regexp)) {\n      // Replace the regexp literal string with the first match group: ([gimy]*)\n      // If no flag is present, this will be a blank string\n      flags = regexp.replace(/.*\\/([gimy]*)$/, '$1');\n      // Again, replace the regexp literal string with the first match group:\n      // everything excluding the opening and closing slashes and the flags\n      regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');\n    } else {\n      // Anchor regexp:\n      regexp = '^' + regexp + '$';\n    }\n    return new RegExp(regexp, flags);\n  }\n};\n\nvar convertArrayRequirement = function(string, length) {\n  var m = string.match(/^\\s*\\[(.*)\\]\\s*$/);\n  if (!m)\n    throw 'Requirement is not an array: \"' + string + '\"';\n  var values = m[1].split(',').map(ParsleyUtils.trimString);\n  if (values.length !== length)\n    throw 'Requirement has ' + values.length + ' values when ' + length + ' are needed';\n  return values;\n};\n\nvar convertRequirement = function(requirementType, string) {\n  var converter = requirementConverters[requirementType || 'string'];\n  if (!converter)\n    throw 'Unknown requirement specification: \"' + requirementType + '\"';\n  return converter(string);\n};\n\nvar convertExtraOptionRequirement = function(requirementSpec, string, extraOptionReader) {\n  var main = null;\n  var extra = {};\n  for (var key in requirementSpec) {\n    if (key) {\n      var value = extraOptionReader(key);\n      if ('string' === typeof value)\n        value = convertRequirement(requirementSpec[key], value);\n      extra[key] = value;\n    } else {\n      main = convertRequirement(requirementSpec[key], string);\n    }\n  }\n  return [main, extra];\n};\n\n// A Validator needs to implement the methods `validate` and `parseRequirements`\n\nvar ParsleyValidator = function(spec) {\n  $.extend(true, this, spec);\n};\n\nParsleyValidator.prototype = {\n  // Returns `true` iff the given `value` is valid according the given requirements.\n  validate: function(value, requirementFirstArg) {\n    if (this.fn) { // Legacy style validator\n\n      if (arguments.length > 3)  // If more args then value, requirement, instance...\n        requirementFirstArg = [].slice.call(arguments, 1, -1);  // Skip first arg (value) and last (instance), combining the rest\n      return this.fn.call(this, value, requirementFirstArg);\n    }\n\n    if ($.isArray(value)) {\n      if (!this.validateMultiple)\n        throw 'Validator `' + this.name + '` does not handle multiple values';\n      return this.validateMultiple(...arguments);\n    } else {\n      if (this.validateNumber) {\n        if (isNaN(value))\n          return false;\n        arguments[0] = parseFloat(arguments[0]);\n        return this.validateNumber(...arguments);\n      }\n      if (this.validateString) {\n        return this.validateString(...arguments);\n      }\n      throw 'Validator `' + this.name + '` only handles multiple values';\n    }\n  },\n\n  // Parses `requirements` into an array of arguments,\n  // according to `this.requirementType`\n  parseRequirements: function(requirements, extraOptionReader) {\n    if ('string' !== typeof requirements) {\n      // Assume requirement already parsed\n      // but make sure we return an array\n      return $.isArray(requirements) ? requirements : [requirements];\n    }\n    var type = this.requirementType;\n    if ($.isArray(type)) {\n      var values = convertArrayRequirement(requirements, type.length);\n      for (var i = 0; i < values.length; i++)\n        values[i] = convertRequirement(type[i], values[i]);\n      return values;\n    } else if ($.isPlainObject(type)) {\n      return convertExtraOptionRequirement(type, requirements, extraOptionReader);\n    } else {\n      return [convertRequirement(type, requirements)];\n    }\n  },\n  // Defaults:\n  requirementType: 'string',\n\n  priority: 2\n\n};\n\nexport default ParsleyValidator;\n","import $ from 'jquery';\nimport ParsleyUtils from './utils';\nimport ParsleyDefaults from './defaults';\nimport ParsleyValidator from './validator';\n\nvar ParsleyValidatorRegistry = function (validators, catalog) {\n  this.__class__ = 'ParsleyValidatorRegistry';\n\n  // Default Parsley locale is en\n  this.locale = 'en';\n\n  this.init(validators || {}, catalog || {});\n};\n\nvar typeRegexes =  {\n  email: /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i,\n\n  // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers\n  number: /^-?(\\d*\\.)?\\d+(e[-+]?\\d+)?$/i,\n\n  integer: /^-?\\d+$/,\n\n  digits: /^\\d+$/,\n\n  alphanum: /^\\w+$/i,\n\n  url: new RegExp(\n      \"^\" +\n        // protocol identifier\n        \"(?:(?:https?|ftp)://)?\" + // ** mod: make scheme optional\n        // user:pass authentication\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n        \"(?:\" +\n          // IP address exclusion\n          // private & local networks\n          // \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +   // ** mod: allow local networks\n          // \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n          // \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\" +  // ** mod: allow local networks\n          // IP address dotted notation octets\n          // excludes loopback network 0.0.0.0\n          // excludes reserved space >= 224.0.0.0\n          // excludes network & broacast addresses\n          // (first & last IP address of each class)\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n        \"|\" +\n          // host name\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n          // domain name\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n          // TLD identifier\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\" +\n        \")\" +\n        // port number\n        \"(?::\\\\d{2,5})?\" +\n        // resource path\n        \"(?:/\\\\S*)?\" +\n      \"$\", 'i'\n    )\n};\ntypeRegexes.range = typeRegexes.number;\n\n// See http://stackoverflow.com/a/10454560/8279\nvar decimalPlaces = num => {\n  var match = ('' + num).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n  if (!match) { return 0; }\n  return Math.max(\n       0,\n       // Number of digits right of decimal point.\n       (match[1] ? match[1].length : 0) -\n       // Adjust for scientific notation.\n       (match[2] ? +match[2] : 0));\n};\n\nParsleyValidatorRegistry.prototype = {\n  init: function (validators, catalog) {\n    this.catalog = catalog;\n    // Copy prototype's validators:\n    this.validators = $.extend({}, this.validators);\n\n    for (var name in validators)\n      this.addValidator(name, validators[name].fn, validators[name].priority);\n\n    window.Parsley.trigger('parsley:validator:init');\n  },\n\n  // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n\n  setLocale: function (locale) {\n    if ('undefined' === typeof this.catalog[locale])\n      throw new Error(locale + ' is not available in the catalog');\n\n    this.locale = locale;\n\n    return this;\n  },\n\n  // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`\n  addCatalog: function (locale, messages, set) {\n    if ('object' === typeof messages)\n      this.catalog[locale] = messages;\n\n    if (true === set)\n      return this.setLocale(locale);\n\n    return this;\n  },\n\n  // Add a specific message for a given constraint in a given locale\n  addMessage: function (locale, name, message) {\n    if ('undefined' === typeof this.catalog[locale])\n      this.catalog[locale] = {};\n\n    this.catalog[locale][name] = message;\n\n    return this;\n  },\n\n  // Add messages for a given locale\n  addMessages: function (locale, nameMessageObject) {\n    for (var name in nameMessageObject)\n      this.addMessage(locale, name, nameMessageObject[name]);\n\n    return this;\n  },\n\n  // Add a new validator\n  //\n  //    addValidator('custom', {\n  //        requirementType: ['integer', 'integer'],\n  //        validateString: function(value, from, to) {},\n  //        priority: 22,\n  //        messages: {\n  //          en: \"Hey, that's no good\",\n  //          fr: \"Aye aye, pas bon du tout\",\n  //        }\n  //    })\n  //\n  // Old API was addValidator(name, function, priority)\n  //\n  addValidator: function (name, arg1, arg2) {\n    if (this.validators[name])\n      ParsleyUtils.warn('Validator \"' + name + '\" is already defined.');\n    else if (ParsleyDefaults.hasOwnProperty(name)) {\n      ParsleyUtils.warn('\"' + name + '\" is a restricted keyword and is not a valid validator name.');\n      return;\n    }\n    return this._setValidator(...arguments);\n  },\n\n  updateValidator: function (name, arg1, arg2) {\n    if (!this.validators[name]) {\n      ParsleyUtils.warn('Validator \"' + name + '\" is not already defined.');\n      return this.addValidator(...arguments);\n    }\n    return this._setValidator(...arguments);\n  },\n\n  removeValidator: function (name) {\n    if (!this.validators[name])\n      ParsleyUtils.warn('Validator \"' + name + '\" is not defined.');\n\n    delete this.validators[name];\n\n    return this;\n  },\n\n  _setValidator: function (name, validator, priority) {\n    if ('object' !== typeof validator) {\n      // Old style validator, with `fn` and `priority`\n      validator = {\n        fn: validator,\n        priority: priority\n      };\n    }\n    if (!validator.validate) {\n      validator = new ParsleyValidator(validator);\n    }\n    this.validators[name] = validator;\n\n    for (var locale in validator.messages || {})\n      this.addMessage(locale, name, validator.messages[locale]);\n\n    return this;\n  },\n\n  getErrorMessage: function (constraint) {\n    var message;\n\n    // Type constraints are a bit different, we have to match their requirements too to find right error message\n    if ('type' === constraint.name) {\n      var typeMessages = this.catalog[this.locale][constraint.name] || {};\n      message = typeMessages[constraint.requirements];\n    } else\n      message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);\n\n    return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;\n  },\n\n  // Kind of light `sprintf()` implementation\n  formatMessage: function (string, parameters) {\n    if ('object' === typeof parameters) {\n      for (var i in parameters)\n        string = this.formatMessage(string, parameters[i]);\n\n      return string;\n    }\n\n    return 'string' === typeof string ? string.replace(/%s/i, parameters) : '';\n  },\n\n  // Here is the Parsley default validators list.\n  // A validator is an object with the following key values:\n  //  - priority: an integer\n  //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these\n  //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise\n  // Alternatively, a validator can be a function that returns such an object\n  //\n  validators: {\n    notblank: {\n      validateString: function(value) {\n        return /\\S/.test(value);\n      },\n      priority: 2\n    },\n    required: {\n      validateMultiple: function(values) {\n        return values.length > 0;\n      },\n      validateString: function(value) {\n        return /\\S/.test(value);\n      },\n      priority: 512\n    },\n    type: {\n      validateString: function(value, type, {step = 'any', base = 0} = {}) {\n        var regex = typeRegexes[type];\n        if (!regex) {\n          throw new Error('validator type `' + type + '` is not supported');\n        }\n        if (!regex.test(value))\n          return false;\n        if ('number' === type) {\n          if (!/^any$/i.test(step || '')) {\n            var nb = Number(value);\n            var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));\n            if (decimalPlaces(nb) > decimals) // Value can't have too many decimals\n              return false;\n            // Be careful of rounding errors by using integers.\n            var toInt = f => Math.round(f * Math.pow(10, decimals));\n            if ((toInt(nb) - toInt(base)) % toInt(step) != 0)\n              return false;\n          }\n        }\n        return true;\n      },\n      requirementType: {\n        '': 'string',\n        step: 'string',\n        base: 'number'\n      },\n      priority: 256\n    },\n    pattern: {\n      validateString: function(value, regexp) {\n        return regexp.test(value);\n      },\n      requirementType: 'regexp',\n      priority: 64\n    },\n    minlength: {\n      validateString: function (value, requirement) {\n        return value.length >= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    maxlength: {\n      validateString: function (value, requirement) {\n        return value.length <= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    length: {\n      validateString: function (value, min, max) {\n        return value.length >= min && value.length <= max;\n      },\n      requirementType: ['integer', 'integer'],\n      priority: 30\n    },\n    mincheck: {\n      validateMultiple: function (values, requirement) {\n        return values.length >= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    maxcheck: {\n      validateMultiple: function (values, requirement) {\n        return values.length <= requirement;\n      },\n      requirementType: 'integer',\n      priority: 30\n    },\n    check: {\n      validateMultiple: function (values, min, max) {\n        return values.length >= min && values.length <= max;\n      },\n      requirementType: ['integer', 'integer'],\n      priority: 30\n    },\n    min: {\n      validateNumber: function (value, requirement) {\n        return value >= requirement;\n      },\n      requirementType: 'number',\n      priority: 30\n    },\n    max: {\n      validateNumber: function (value, requirement) {\n        return value <= requirement;\n      },\n      requirementType: 'number',\n      priority: 30\n    },\n    range: {\n      validateNumber: function (value, min, max) {\n        return value >= min && value <= max;\n      },\n      requirementType: ['number', 'number'],\n      priority: 30\n    },\n    equalto: {\n      validateString: function (value, refOrValue) {\n        var $reference = $(refOrValue);\n        if ($reference.length)\n          return value === $reference.val();\n        else\n          return value === refOrValue;\n      },\n      priority: 256\n    }\n  }\n};\n\nexport default ParsleyValidatorRegistry;\n","import $ from 'jquery';\nimport ParsleyUtils from './utils';\n\nvar ParsleyUI = {};\n\nvar diffResults = function (newResult, oldResult, deep) {\n  var added = [];\n  var kept = [];\n\n  for (var i = 0; i < newResult.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < oldResult.length; j++)\n      if (newResult[i].assert.name === oldResult[j].assert.name) {\n        found = true;\n        break;\n      }\n\n    if (found)\n      kept.push(newResult[i]);\n    else\n      added.push(newResult[i]);\n  }\n\n  return {\n    kept: kept,\n    added: added,\n    removed: !deep ? diffResults(oldResult, newResult, true).added : []\n  };\n};\n\nParsleyUI.Form = {\n\n  _actualizeTriggers: function () {\n    this.$element.on('submit.Parsley', evt => { this.onSubmitValidate(evt); });\n    this.$element.on('click.Parsley', ParsleyUtils._SubmitSelector, evt => { this.onSubmitButton(evt); });\n\n    // UI could be disabled\n    if (false === this.options.uiEnabled)\n      return;\n\n    this.$element.attr('novalidate', '');\n  },\n\n  focus: function () {\n    this._focusedField = null;\n\n    if (true === this.validationResult || 'none' === this.options.focus)\n      return null;\n\n    for (var i = 0; i < this.fields.length; i++) {\n      var field = this.fields[i];\n      if (true !== field.validationResult && field.validationResult.length > 0 && 'undefined' === typeof field.options.noFocus) {\n        this._focusedField = field.$element;\n        if ('first' === this.options.focus)\n          break;\n      }\n    }\n\n    if (null === this._focusedField)\n      return null;\n\n    return this._focusedField.focus();\n  },\n\n  _destroyUI: function () {\n    // Reset all event listeners\n    this.$element.off('.Parsley');\n  }\n\n};\n\nParsleyUI.Field = {\n\n  _reflowUI: function () {\n    this._buildUI();\n\n    // If this field doesn't have an active UI don't bother doing something\n    if (!this._ui)\n      return;\n\n    // Diff between two validation results\n    var diff = diffResults(this.validationResult, this._ui.lastValidationResult);\n\n    // Then store current validation result for next reflow\n    this._ui.lastValidationResult = this.validationResult;\n\n    // Handle valid / invalid / none field class\n    this._manageStatusClass();\n\n    // Add, remove, updated errors messages\n    this._manageErrorsMessages(diff);\n\n    // Triggers impl\n    this._actualizeTriggers();\n\n    // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user\n    if ((diff.kept.length || diff.added.length) && !this._failedOnce) {\n      this._failedOnce = true;\n      this._actualizeTriggers();\n    }\n  },\n\n  // Returns an array of field's error message(s)\n  getErrorsMessages: function () {\n    // No error message, field is valid\n    if (true === this.validationResult)\n      return [];\n\n    var messages = [];\n\n    for (var i = 0; i < this.validationResult.length; i++)\n      messages.push(this.validationResult[i].errorMessage ||\n       this._getErrorMessage(this.validationResult[i].assert));\n\n    return messages;\n  },\n\n  // It's a goal of Parsley that this method is no longer required [#1073]\n  addError: function (name, {message, assert, updateClass = true} = {}) {\n    this._buildUI();\n    this._addError(name, {message, assert});\n\n    if (updateClass)\n      this._errorClass();\n  },\n\n  // It's a goal of Parsley that this method is no longer required [#1073]\n  updateError: function (name, {message, assert, updateClass = true} = {}) {\n    this._buildUI();\n    this._updateError(name, {message, assert});\n\n    if (updateClass)\n      this._errorClass();\n  },\n\n  // It's a goal of Parsley that this method is no longer required [#1073]\n  removeError: function (name, {updateClass = true} = {}) {\n    this._buildUI();\n    this._removeError(name);\n\n    // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult\n    // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.\n    if (updateClass)\n      this._manageStatusClass();\n  },\n\n  _manageStatusClass: function () {\n    if (this.hasConstraints() && this.needsValidation() && true === this.validationResult)\n      this._successClass();\n    else if (this.validationResult.length > 0)\n      this._errorClass();\n    else\n      this._resetClass();\n  },\n\n  _manageErrorsMessages: function (diff) {\n    if ('undefined' !== typeof this.options.errorsMessagesDisabled)\n      return;\n\n    // Case where we have errorMessage option that configure an unique field error message, regardless failing validators\n    if ('undefined' !== typeof this.options.errorMessage) {\n      if ((diff.added.length || diff.kept.length)) {\n        this._insertErrorWrapper();\n\n        if (0 === this._ui.$errorsWrapper.find('.parsley-custom-error-message').length)\n          this._ui.$errorsWrapper\n            .append(\n              $(this.options.errorTemplate)\n              .addClass('parsley-custom-error-message')\n            );\n\n        return this._ui.$errorsWrapper\n          .addClass('filled')\n          .find('.parsley-custom-error-message')\n          .html(this.options.errorMessage);\n      }\n\n      return this._ui.$errorsWrapper\n        .removeClass('filled')\n        .find('.parsley-custom-error-message')\n        .remove();\n    }\n\n    // Show, hide, update failing constraints messages\n    for (var i = 0; i < diff.removed.length; i++)\n      this._removeError(diff.removed[i].assert.name);\n\n    for (i = 0; i < diff.added.length; i++)\n      this._addError(diff.added[i].assert.name, {message: diff.added[i].errorMessage, assert: diff.added[i].assert});\n\n    for (i = 0; i < diff.kept.length; i++)\n      this._updateError(diff.kept[i].assert.name, {message: diff.kept[i].errorMessage, assert: diff.kept[i].assert});\n  },\n\n\n  _addError: function (name, {message, assert}) {\n    this._insertErrorWrapper();\n    this._ui.$errorsWrapper\n      .addClass('filled')\n      .append(\n        $(this.options.errorTemplate)\n        .addClass('parsley-' + name)\n        .html(message || this._getErrorMessage(assert))\n      );\n  },\n\n  _updateError: function (name, {message, assert}) {\n    this._ui.$errorsWrapper\n      .addClass('filled')\n      .find('.parsley-' + name)\n      .html(message || this._getErrorMessage(assert));\n  },\n\n  _removeError: function (name) {\n    this._ui.$errorsWrapper\n      .removeClass('filled')\n      .find('.parsley-' + name)\n      .remove();\n  },\n\n  _getErrorMessage: function (constraint) {\n    var customConstraintErrorMessage = constraint.name + 'Message';\n\n    if ('undefined' !== typeof this.options[customConstraintErrorMessage])\n      return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);\n\n    return window.Parsley.getErrorMessage(constraint);\n  },\n\n  _buildUI: function () {\n    // UI could be already built or disabled\n    if (this._ui || false === this.options.uiEnabled)\n      return;\n\n    var _ui = {};\n\n    // Give field its Parsley id in DOM\n    this.$element.attr(this.options.namespace + 'id', this.__id__);\n\n    /** Generate important UI elements and store them in this **/\n    // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes\n    _ui.$errorClassHandler = this._manageClassHandler();\n\n    // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer\n    _ui.errorsWrapperId = 'parsley-id-' + (this.options.multiple ? 'multiple-' + this.options.multiple : this.__id__);\n    _ui.$errorsWrapper = $(this.options.errorsWrapper).attr('id', _ui.errorsWrapperId);\n\n    // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly\n    _ui.lastValidationResult = [];\n    _ui.validationInformationVisible = false;\n\n    // Store it in this for later\n    this._ui = _ui;\n  },\n\n  // Determine which element will have `parsley-error` and `parsley-success` classes\n  _manageClassHandler: function () {\n    // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`\n    if ('string' === typeof this.options.classHandler && $(this.options.classHandler).length)\n      return $(this.options.classHandler);\n\n    // Class handled could also be determined by function given in Parsley options\n    var $handler = this.options.classHandler.call(this, this);\n\n    // If this function returned a valid existing DOM element, go for it\n    if ('undefined' !== typeof $handler && $handler.length)\n      return $handler;\n\n    return this._inputHolder();\n  },\n\n  _inputHolder: function() {\n    // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container\n    if (!this.options.multiple || this.$element.is('select'))\n      return this.$element;\n\n    // But if multiple element (radio, checkbox), that would be their parent\n    return this.$element.parent();\n  },\n\n  _insertErrorWrapper: function () {\n    var $errorsContainer;\n\n    // Nothing to do if already inserted\n    if (0 !== this._ui.$errorsWrapper.parent().length)\n      return this._ui.$errorsWrapper.parent();\n\n    if ('string' === typeof this.options.errorsContainer) {\n      if ($(this.options.errorsContainer).length)\n        return $(this.options.errorsContainer).append(this._ui.$errorsWrapper);\n      else\n        ParsleyUtils.warn('The errors container `' + this.options.errorsContainer + '` does not exist in DOM');\n    } else if ('function' === typeof this.options.errorsContainer)\n      $errorsContainer = this.options.errorsContainer.call(this, this);\n\n    if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)\n      return $errorsContainer.append(this._ui.$errorsWrapper);\n\n    return this._inputHolder().after(this._ui.$errorsWrapper);\n  },\n\n  _actualizeTriggers: function () {\n    var $toBind = this._findRelated();\n    var trigger;\n\n    // Remove Parsley events already bound on this field\n    $toBind.off('.Parsley');\n    if (this._failedOnce)\n      $toBind.on(ParsleyUtils.namespaceEvents(this.options.triggerAfterFailure, 'Parsley'), () => {\n        this._validateIfNeeded();\n      });\n    else if (trigger = ParsleyUtils.namespaceEvents(this.options.trigger, 'Parsley')) {\n      $toBind.on(trigger, event => {\n        this._validateIfNeeded(event);\n      });\n    }\n  },\n\n  _validateIfNeeded: function (event) {\n    // For keyup, keypress, keydown, input... events that could be a little bit obstrusive\n    // do not validate if val length < min threshold on first validation. Once field have been validated once and info\n    // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.\n    if (event && /key|input/.test(event.type))\n      if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold)\n        return;\n\n    if (this.options.debounce) {\n      window.clearTimeout(this._debounced);\n      this._debounced = window.setTimeout(() => this.validate(), this.options.debounce);\n    } else\n      this.validate();\n  },\n\n  _resetUI: function () {\n    // Reset all event listeners\n    this._failedOnce = false;\n    this._actualizeTriggers();\n\n    // Nothing to do if UI never initialized for this field\n    if ('undefined' === typeof this._ui)\n      return;\n\n    // Reset all errors' li\n    this._ui.$errorsWrapper\n      .removeClass('filled')\n      .children()\n      .remove();\n\n    // Reset validation class\n    this._resetClass();\n\n    // Reset validation flags and last validation result\n    this._ui.lastValidationResult = [];\n    this._ui.validationInformationVisible = false;\n  },\n\n  _destroyUI: function () {\n    this._resetUI();\n\n    if ('undefined' !== typeof this._ui)\n      this._ui.$errorsWrapper.remove();\n\n    delete this._ui;\n  },\n\n  _successClass: function () {\n    this._ui.validationInformationVisible = true;\n    this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);\n  },\n  _errorClass: function () {\n    this._ui.validationInformationVisible = true;\n    this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);\n  },\n  _resetClass: function () {\n    this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);\n  }\n};\n\nexport default ParsleyUI;\n","import $ from 'jquery';\nimport ParsleyAbstract from './abstract';\nimport ParsleyUtils from './utils';\n\nvar ParsleyForm = function (element, domOptions, options) {\n  this.__class__ = 'ParsleyForm';\n\n  this.$element = $(element);\n  this.domOptions = domOptions;\n  this.options = options;\n  this.parent = window.Parsley;\n\n  this.fields = [];\n  this.validationResult = null;\n};\n\nvar statusMapping = {pending: null, resolved: true, rejected: false};\n\nParsleyForm.prototype = {\n  onSubmitValidate: function (event) {\n    // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior\n    if (true === event.parsley)\n      return;\n\n    // If we didn't come here through a submit button, use the first one in the form\n    var $submitSource = this._$submitSource || this.$element.find(ParsleyUtils._SubmitSelector).first();\n    this._$submitSource = null;\n    this.$element.find('.parsley-synthetic-submit-button').prop('disabled', true);\n    if ($submitSource.is('[formnovalidate]'))\n      return;\n\n    var promise = this.whenValidate({event});\n\n    if ('resolved' === promise.state() && false !== this._trigger('submit')) {\n      // All good, let event go through. We make this distinction because browsers\n      // differ in their handling of `submit` being called from inside a submit event [#1047]\n    } else {\n      // Rejected or pending: cancel this submit\n      event.stopImmediatePropagation();\n      event.preventDefault();\n      if ('pending' === promise.state())\n        promise.done(() => { this._submit($submitSource); });\n    }\n  },\n\n  onSubmitButton: function(event) {\n    this._$submitSource = $(event.currentTarget);\n  },\n  // internal\n  // _submit submits the form, this time without going through the validations.\n  // Care must be taken to \"fake\" the actual submit button being clicked.\n  _submit: function ($submitSource) {\n    if (false === this._trigger('submit'))\n      return;\n    // Add submit button's data\n    if ($submitSource) {\n      var $synthetic = this.$element.find('.parsley-synthetic-submit-button').prop('disabled', false);\n      if (0 === $synthetic.length)\n        $synthetic = $('<input class=\"parsley-synthetic-submit-button\" type=\"hidden\">').appendTo(this.$element);\n      $synthetic.attr({\n        name: $submitSource.attr('name'),\n        value: $submitSource.attr('value')\n      });\n    }\n\n    this.$element.trigger($.extend($.Event('submit'), {parsley: true}));\n  },\n\n  // Performs validation on fields while triggering events.\n  // @returns `true` if all validations succeeds, `false`\n  // if a failure is immediately detected, or `null`\n  // if dependant on a promise.\n  // Consider using `whenValidate` instead.\n  validate: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      ParsleyUtils.warnOnce('Calling validate on a parsley form without passing arguments as an object is deprecated.');\n      var [group, force, event] = arguments;\n      options = {group, force, event};\n    }\n    return statusMapping[ this.whenValidate(options).state() ];\n  },\n\n  whenValidate: function ({group, force, event} = {}) {\n    this.submitEvent = event;\n    if (event) {\n      this.submitEvent = $.extend({}, event, {preventDefault: () => {\n        ParsleyUtils.warnOnce(\"Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`\");\n        this.validationResult = false;\n      }});\n    }\n    this.validationResult = true;\n\n    // fire validate event to eventually modify things before every validation\n    this._trigger('validate');\n\n    // Refresh form DOM options and form's fields that could have changed\n    this._refreshFields();\n\n    var promises = this._withoutReactualizingFormOptions(() => {\n      return $.map(this.fields, field => field.whenValidate({force, group}));\n    });\n\n    return ParsleyUtils.all(promises)\n      .done(  () => { this._trigger('success'); })\n      .fail(  () => {\n        this.validationResult = false;\n        this.focus();\n        this._trigger('error');\n      })\n      .always(() => { this._trigger('validated'); })\n      .pipe(...this._pipeAccordingToValidationResult());\n  },\n\n  // Iterate over refreshed fields, and stop on first failure.\n  // Returns `true` if all fields are valid, `false` if a failure is detected\n  // or `null` if the result depends on an unresolved promise.\n  // Prefer using `whenValid` instead.\n  isValid: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      ParsleyUtils.warnOnce('Calling isValid on a parsley form without passing arguments as an object is deprecated.');\n      var [group, force] = arguments;\n      options = {group, force};\n    }\n    return statusMapping[ this.whenValid(options).state() ];\n  },\n\n  // Iterate over refreshed fields and validate them.\n  // Returns a promise.\n  // A validation that immediately fails will interrupt the validations.\n  whenValid: function ({group, force} = {}) {\n    this._refreshFields();\n\n    var promises = this._withoutReactualizingFormOptions(() => {\n      return $.map(this.fields, field => field.whenValid({group, force}));\n    });\n    return ParsleyUtils.all(promises);\n  },\n\n  _refreshFields: function () {\n    return this.actualizeOptions()._bindFields();\n  },\n\n  _bindFields: function () {\n    var oldFields = this.fields;\n\n    this.fields = [];\n    this.fieldsMappedById = {};\n\n    this._withoutReactualizingFormOptions(() => {\n      this.$element\n      .find(this.options.inputs)\n      .not(this.options.excluded)\n      .each((_, element) => {\n        var fieldInstance = new window.Parsley.Factory(element, {}, this);\n\n        // Only add valid and not excluded `ParsleyField` and `ParsleyFieldMultiple` children\n        if (('ParsleyField' === fieldInstance.__class__ || 'ParsleyFieldMultiple' === fieldInstance.__class__) && (true !== fieldInstance.options.excluded))\n          if ('undefined' === typeof this.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__]) {\n            this.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__] = fieldInstance;\n            this.fields.push(fieldInstance);\n          }\n      });\n\n      $.each(ParsleyUtils.difference(oldFields, this.fields), (_, field) => {\n        field._trigger('reset');\n      });\n    });\n    return this;\n  },\n\n  // Internal only.\n  // Looping on a form's fields to do validation or similar\n  // will trigger reactualizing options on all of them, which\n  // in turn will reactualize the form's options.\n  // To avoid calling actualizeOptions so many times on the form\n  // for nothing, _withoutReactualizingFormOptions temporarily disables\n  // the method actualizeOptions on this form while `fn` is called.\n  _withoutReactualizingFormOptions: function (fn) {\n    var oldActualizeOptions = this.actualizeOptions;\n    this.actualizeOptions = function () { return this; };\n    var result = fn();\n    this.actualizeOptions = oldActualizeOptions;\n    return result;\n  },\n\n  // Internal only.\n  // Shortcut to trigger an event\n  // Returns true iff event is not interrupted and default not prevented.\n  _trigger: function (eventName) {\n    return this.trigger('form:' + eventName);\n  }\n\n};\n\nexport default ParsleyForm;\n","import $ from 'jquery';\nimport ParsleyUtils from '../utils';\nimport ParsleyValidator from '../validator';\n\n\nvar ConstraintFactory = function (parsleyField, name, requirements, priority, isDomConstraint) {\n  if (!/ParsleyField/.test(parsleyField.__class__))\n    throw new Error('ParsleyField or ParsleyFieldMultiple instance expected');\n\n  var validatorSpec = window.Parsley._validatorRegistry.validators[name];\n  var validator = new ParsleyValidator(validatorSpec);\n\n  $.extend(this, {\n    validator: validator,\n    name: name,\n    requirements: requirements,\n    priority: priority || parsleyField.options[name + 'Priority'] || validator.priority,\n    isDomConstraint: true === isDomConstraint\n  });\n  this._parseRequirements(parsleyField.options);\n};\n\nvar capitalize = function(str) {\n  var cap = str[0].toUpperCase();\n  return cap + str.slice(1);\n};\n\nConstraintFactory.prototype = {\n  validate: function(value, instance) {\n    return this.validator.validate(value, ...this.requirementList, instance);\n  },\n\n  _parseRequirements: function(options) {\n    this.requirementList = this.validator.parseRequirements(this.requirements,\n      key => options[this.name + capitalize(key)]\n    );\n  }\n};\n\nexport default ConstraintFactory;\n\n","import $ from 'jquery';\nimport ConstraintFactory from './factory/constraint';\nimport ParsleyUI from './ui';\nimport ParsleyUtils from './utils';\n\nvar ParsleyField = function (field, domOptions, options, parsleyFormInstance) {\n  this.__class__ = 'ParsleyField';\n\n  this.$element = $(field);\n\n  // Set parent if we have one\n  if ('undefined' !== typeof parsleyFormInstance) {\n    this.parent = parsleyFormInstance;\n  }\n\n  this.options = options;\n  this.domOptions = domOptions;\n\n  // Initialize some properties\n  this.constraints = [];\n  this.constraintsByName = {};\n  this.validationResult = true;\n\n  // Bind constraints\n  this._bindConstraints();\n};\n\nvar statusMapping = {pending: null, resolved: true, rejected: false};\n\nParsleyField.prototype = {\n  // # Public API\n  // Validate field and trigger some events for mainly `ParsleyUI`\n  // @returns `true`, an array of the validators that failed, or\n  // `null` if validation is not finished. Prefer using whenValidate\n  validate: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      ParsleyUtils.warnOnce('Calling validate on a parsley field without passing arguments as an object is deprecated.');\n      options = {options};\n    }\n    var promise = this.whenValidate(options);\n    if (!promise)  // If excluded with `group` option\n      return true;\n    switch (promise.state()) {\n      case 'pending': return null;\n      case 'resolved': return true;\n      case 'rejected': return this.validationResult;\n    }\n  },\n\n  // Validate field and trigger some events for mainly `ParsleyUI`\n  // @returns a promise that succeeds only when all validations do\n  // or `undefined` if field is not in the given `group`.\n  whenValidate: function ({force, group} =  {}) {\n    // do not validate a field if not the same as given validation group\n    this.refreshConstraints();\n    if (group && !this._isInGroup(group))\n      return;\n\n    this.value = this.getValue();\n\n    // Field Validate event. `this.value` could be altered for custom needs\n    this._trigger('validate');\n\n    return this.whenValid({force, value: this.value, _refreshed: true})\n      .always(() => { this._reflowUI(); })\n      .done(() =>   { this._trigger('success'); })\n      .fail(() =>   { this._trigger('error'); })\n      .always(() => { this._trigger('validated'); })\n      .pipe(...this._pipeAccordingToValidationResult());\n  },\n\n  hasConstraints: function () {\n    return 0 !== this.constraints.length;\n  },\n\n  // An empty optional field does not need validation\n  needsValidation: function (value) {\n    if ('undefined' === typeof value)\n      value = this.getValue();\n\n    // If a field is empty and not required, it is valid\n    // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators\n    if (!value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty)\n      return false;\n\n    return true;\n  },\n\n  _isInGroup: function (group) {\n    if ($.isArray(this.options.group))\n      return -1 !== $.inArray(group, this.options.group);\n    return this.options.group === group;\n  },\n\n  // Just validate field. Do not trigger any event.\n  // Returns `true` iff all constraints pass, `false` if there are failures,\n  // or `null` if the result can not be determined yet (depends on a promise)\n  // See also `whenValid`.\n  isValid: function (options) {\n    if (arguments.length >= 1 && !$.isPlainObject(options)) {\n      ParsleyUtils.warnOnce('Calling isValid on a parsley field without passing arguments as an object is deprecated.');\n      var [force, value] = arguments;\n      options = {force, value};\n    }\n    var promise = this.whenValid(options);\n    if (!promise) // Excluded via `group`\n      return true;\n    return statusMapping[promise.state()];\n  },\n\n  // Just validate field. Do not trigger any event.\n  // @returns a promise that succeeds only when all validations do\n  // or `undefined` if the field is not in the given `group`.\n  // The argument `force` will force validation of empty fields.\n  // If a `value` is given, it will be validated instead of the value of the input.\n  whenValid: function ({force = false, value, group, _refreshed} = {}) {\n    // Recompute options and rebind constraints to have latest changes\n    if (!_refreshed)\n      this.refreshConstraints();\n    // do not validate a field if not the same as given validation group\n    if (group && !this._isInGroup(group))\n      return;\n\n    this.validationResult = true;\n\n    // A field without constraint is valid\n    if (!this.hasConstraints())\n      return $.when();\n\n    // Value could be passed as argument, needed to add more power to 'field:validate'\n    if ('undefined' === typeof value || null === value)\n      value = this.getValue();\n\n    if (!this.needsValidation(value) && true !== force)\n      return $.when();\n\n    var groupedConstraints = this._getGroupedConstraints();\n    var promises = [];\n    $.each(groupedConstraints, (_, constraints) => {\n      // Process one group of constraints at a time, we validate the constraints\n      // and combine the promises together.\n      var promise = ParsleyUtils.all(\n        $.map(constraints, constraint => this._validateConstraint(value, constraint))\n      );\n      promises.push(promise);\n      if (promise.state() === 'rejected')\n        return false; // Interrupt processing if a group has already failed\n    });\n    return ParsleyUtils.all(promises);\n  },\n\n  // @returns a promise\n  _validateConstraint: function(value, constraint) {\n    var result = constraint.validate(value, this);\n    // Map false to a failed promise\n    if (false === result)\n      result = $.Deferred().reject();\n    // Make sure we return a promise and that we record failures\n    return ParsleyUtils.all([result]).fail(errorMessage => {\n      if (!(this.validationResult instanceof Array))\n        this.validationResult = [];\n      this.validationResult.push({\n        assert: constraint,\n        errorMessage: 'string' === typeof errorMessage && errorMessage\n      });\n    });\n  },\n\n  // @returns Parsley field computed value that could be overrided or configured in DOM\n  getValue: function () {\n    var value;\n\n    // Value could be overriden in DOM or with explicit options\n    if ('function' === typeof this.options.value)\n      value = this.options.value(this);\n    else if ('undefined' !== typeof this.options.value)\n      value = this.options.value;\n    else\n      value = this.$element.val();\n\n    // Handle wrong DOM or configurations\n    if ('undefined' === typeof value || null === value)\n      return '';\n\n    return this._handleWhitespace(value);\n  },\n\n  // Actualize options that could have change since previous validation\n  // Re-bind accordingly constraints (could be some new, removed or updated)\n  refreshConstraints: function () {\n    return this.actualizeOptions()._bindConstraints();\n  },\n\n  /**\n  * Add a new constraint to a field\n  *\n  * @param {String}   name\n  * @param {Mixed}    requirements      optional\n  * @param {Number}   priority          optional\n  * @param {Boolean}  isDomConstraint   optional\n  */\n  addConstraint: function (name, requirements, priority, isDomConstraint) {\n\n    if (window.Parsley._validatorRegistry.validators[name]) {\n      var constraint = new ConstraintFactory(this, name, requirements, priority, isDomConstraint);\n\n      // if constraint already exist, delete it and push new version\n      if ('undefined' !== this.constraintsByName[constraint.name])\n        this.removeConstraint(constraint.name);\n\n      this.constraints.push(constraint);\n      this.constraintsByName[constraint.name] = constraint;\n    }\n\n    return this;\n  },\n\n  // Remove a constraint\n  removeConstraint: function (name) {\n    for (var i = 0; i < this.constraints.length; i++)\n      if (name === this.constraints[i].name) {\n        this.constraints.splice(i, 1);\n        break;\n      }\n    delete this.constraintsByName[name];\n    return this;\n  },\n\n  // Update a constraint (Remove + re-add)\n  updateConstraint: function (name, parameters, priority) {\n    return this.removeConstraint(name)\n      .addConstraint(name, parameters, priority);\n  },\n\n  // # Internals\n\n  // Internal only.\n  // Bind constraints from config + options + DOM\n  _bindConstraints: function () {\n    var constraints = [];\n    var constraintsByName = {};\n\n    // clean all existing DOM constraints to only keep javascript user constraints\n    for (var i = 0; i < this.constraints.length; i++)\n      if (false === this.constraints[i].isDomConstraint) {\n        constraints.push(this.constraints[i]);\n        constraintsByName[this.constraints[i].name] = this.constraints[i];\n      }\n\n    this.constraints = constraints;\n    this.constraintsByName = constraintsByName;\n\n    // then re-add Parsley DOM-API constraints\n    for (var name in this.options)\n      this.addConstraint(name, this.options[name], undefined, true);\n\n    // finally, bind special HTML5 constraints\n    return this._bindHtml5Constraints();\n  },\n\n  // Internal only.\n  // Bind specific HTML5 constraints to be HTML5 compliant\n  _bindHtml5Constraints: function () {\n    // html5 required\n    if (this.$element.attr('required'))\n      this.addConstraint('required', true, undefined, true);\n\n    // html5 pattern\n    if ('string' === typeof this.$element.attr('pattern'))\n      this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);\n\n    // range\n    if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max'))\n      this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);\n\n    // HTML5 min\n    else if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('min'))\n      this.addConstraint('min', this.$element.attr('min'), undefined, true);\n\n    // HTML5 max\n    else if (this.$element.attr('type') !== 'date' && 'undefined' !== typeof this.$element.attr('max'))\n      this.addConstraint('max', this.$element.attr('max'), undefined, true);\n\n\n    // length\n    if ('undefined' !== typeof this.$element.attr('minlength') && 'undefined' !== typeof this.$element.attr('maxlength'))\n      this.addConstraint('length', [this.$element.attr('minlength'), this.$element.attr('maxlength')], undefined, true);\n\n    // HTML5 minlength\n    else if ('undefined' !== typeof this.$element.attr('minlength'))\n      this.addConstraint('minlength', this.$element.attr('minlength'), undefined, true);\n\n    // HTML5 maxlength\n    else if ('undefined' !== typeof this.$element.attr('maxlength'))\n      this.addConstraint('maxlength', this.$element.attr('maxlength'), undefined, true);\n\n\n    // html5 types\n    var type = this.$element.attr('type');\n\n    if ('undefined' === typeof type)\n      return this;\n\n    // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise\n    if ('number' === type) {\n      return this.addConstraint('type', ['number', {\n        step: this.$element.attr('step') || '1',\n        base: this.$element.attr('min') || this.$element.attr('value')\n      }], undefined, true);\n    // Regular other HTML5 supported types\n    } else if (/^(email|url|range)$/i.test(type)) {\n      return this.addConstraint('type', type, undefined, true);\n    }\n    return this;\n  },\n\n  // Internal only.\n  // Field is required if have required constraint without `false` value\n  _isRequired: function () {\n    if ('undefined' === typeof this.constraintsByName.required)\n      return false;\n\n    return false !== this.constraintsByName.required.requirements;\n  },\n\n  // Internal only.\n  // Shortcut to trigger an event\n  _trigger: function (eventName) {\n    return this.trigger('field:' + eventName);\n  },\n\n  // Internal only\n  // Handles whitespace in a value\n  // Use `data-parsley-whitespace=\"squish\"` to auto squish input value\n  // Use `data-parsley-whitespace=\"trim\"` to auto trim input value\n  _handleWhitespace: function (value) {\n    if (true === this.options.trimValue)\n      ParsleyUtils.warnOnce('data-parsley-trim-value=\"true\" is deprecated, please use data-parsley-whitespace=\"trim\"');\n\n    if ('squish' === this.options.whitespace)\n      value = value.replace(/\\s{2,}/g, ' ');\n\n    if (('trim' === this.options.whitespace) || ('squish' === this.options.whitespace) || (true === this.options.trimValue))\n      value = ParsleyUtils.trimString(value);\n\n    return value;\n  },\n\n  // Internal only.\n  // Returns the constraints, grouped by descending priority.\n  // The result is thus an array of arrays of constraints.\n  _getGroupedConstraints: function () {\n    if (false === this.options.priorityEnabled)\n      return [this.constraints];\n\n    var groupedConstraints = [];\n    var index = {};\n\n    // Create array unique of priorities\n    for (var i = 0; i < this.constraints.length; i++) {\n      var p = this.constraints[i].priority;\n      if (!index[p])\n        groupedConstraints.push(index[p] = []);\n      index[p].push(this.constraints[i]);\n    }\n    // Sort them by priority DESC\n    groupedConstraints.sort(function (a, b) { return b[0].priority - a[0].priority; });\n\n    return groupedConstraints;\n  }\n\n};\n\nexport default ParsleyField;\n","import $ from 'jquery';\n\nvar ParsleyMultiple = function () {\n  this.__class__ = 'ParsleyFieldMultiple';\n};\n\nParsleyMultiple.prototype = {\n  // Add new `$element` sibling for multiple field\n  addElement: function ($element) {\n    this.$elements.push($element);\n\n    return this;\n  },\n\n  // See `ParsleyField.refreshConstraints()`\n  refreshConstraints: function () {\n    var fieldConstraints;\n\n    this.constraints = [];\n\n    // Select multiple special treatment\n    if (this.$element.is('select')) {\n      this.actualizeOptions()._bindConstraints();\n\n      return this;\n    }\n\n    // Gather all constraints for each input in the multiple group\n    for (var i = 0; i < this.$elements.length; i++) {\n\n      // Check if element have not been dynamically removed since last binding\n      if (!$('html').has(this.$elements[i]).length) {\n        this.$elements.splice(i, 1);\n        continue;\n      }\n\n      fieldConstraints = this.$elements[i].data('ParsleyFieldMultiple').refreshConstraints().constraints;\n\n      for (var j = 0; j < fieldConstraints.length; j++)\n        this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);\n    }\n\n    return this;\n  },\n\n  // See `ParsleyField.getValue()`\n  getValue: function () {\n    // Value could be overriden in DOM\n    if ('function' === typeof this.options.value)\n      return this.options.value(this);\n    else if ('undefined' !== typeof this.options.value)\n      return this.options.value;\n\n    // Radio input case\n    if (this.$element.is('input[type=radio]'))\n      return this._findRelated().filter(':checked').val() || '';\n\n    // checkbox input case\n    if (this.$element.is('input[type=checkbox]')) {\n      var values = [];\n\n      this._findRelated().filter(':checked').each(function () {\n        values.push($(this).val());\n      });\n\n      return values;\n    }\n\n    // Select multiple case\n    if (this.$element.is('select') && null === this.$element.val())\n      return [];\n\n    // Default case that should never happen\n    return this.$element.val();\n  },\n\n  _init: function () {\n    this.$elements = [this.$element];\n\n    return this;\n  }\n};\n\nexport default ParsleyMultiple;\n","import $ from 'jquery';\nimport ParsleyUtils from './utils';\nimport ParsleyAbstract from './abstract';\nimport ParsleyForm from './form';\nimport ParsleyField from './field';\nimport ParsleyMultiple from './multiple';\n\nvar ParsleyFactory = function (element, options, parsleyFormInstance) {\n  this.$element = $(element);\n\n  // If the element has already been bound, returns its saved Parsley instance\n  var savedparsleyFormInstance = this.$element.data('Parsley');\n  if (savedparsleyFormInstance) {\n\n    // If the saved instance has been bound without a ParsleyForm parent and there is one given in this call, add it\n    if ('undefined' !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {\n      savedparsleyFormInstance.parent = parsleyFormInstance;\n      savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);\n    }\n\n    if ('object' === typeof options) {\n      $.extend(savedparsleyFormInstance.options, options);\n    }\n\n    return savedparsleyFormInstance;\n  }\n\n  // Parsley must be instantiated with a DOM element or jQuery $element\n  if (!this.$element.length)\n    throw new Error('You must bind Parsley on an existing element.');\n\n  if ('undefined' !== typeof parsleyFormInstance && 'ParsleyForm' !== parsleyFormInstance.__class__)\n    throw new Error('Parent instance must be a ParsleyForm instance');\n\n  this.parent = parsleyFormInstance || window.Parsley;\n  return this.init(options);\n};\n\nParsleyFactory.prototype = {\n  init: function (options) {\n    this.__class__ = 'Parsley';\n    this.__version__ = '@@version';\n    this.__id__ = ParsleyUtils.generateID();\n\n    // Pre-compute options\n    this._resetOptions(options);\n\n    // A ParsleyForm instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute\n    if (this.$element.is('form') || (ParsleyUtils.checkAttr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))\n      return this.bind('parsleyForm');\n\n    // Every other element is bound as a `ParsleyField` or `ParsleyFieldMultiple`\n    return this.isMultiple() ? this.handleMultiple() : this.bind('parsleyField');\n  },\n\n  isMultiple: function () {\n    return (this.$element.is('input[type=radio], input[type=checkbox]')) || (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple'));\n  },\n\n  // Multiples fields are a real nightmare :(\n  // Maybe some refactoring would be appreciated here...\n  handleMultiple: function () {\n    var name;\n    var multiple;\n    var parsleyMultipleInstance;\n\n    // Handle multiple name\n    if (this.options.multiple)\n      ; // We already have our 'multiple' identifier\n    else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length)\n      this.options.multiple = name = this.$element.attr('name');\n    else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length)\n      this.options.multiple = this.$element.attr('id');\n\n    // Special select multiple input\n    if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {\n      this.options.multiple = this.options.multiple || this.__id__;\n      return this.bind('parsleyFieldMultiple');\n\n    // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it\n    } else if (!this.options.multiple) {\n      ParsleyUtils.warn('To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);\n      return this;\n    }\n\n    // Remove special chars\n    this.options.multiple = this.options.multiple.replace(/(:|\\.|\\[|\\]|\\{|\\}|\\$)/g, '');\n\n    // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name\n    if ('undefined' !== typeof name) {\n      $('input[name=\"' + name + '\"]').each((i, input) => {\n        if ($(input).is('input[type=radio], input[type=checkbox]'))\n          $(input).attr(this.options.namespace + 'multiple', this.options.multiple);\n      });\n    }\n\n    // Check here if we don't already have a related multiple instance saved\n    var $previouslyRelated = this._findRelated();\n    for (var i = 0; i < $previouslyRelated.length; i++) {\n      parsleyMultipleInstance = $($previouslyRelated.get(i)).data('Parsley');\n      if ('undefined' !== typeof parsleyMultipleInstance) {\n\n        if (!this.$element.data('ParsleyFieldMultiple')) {\n          parsleyMultipleInstance.addElement(this.$element);\n        }\n\n        break;\n      }\n    }\n\n    // Create a secret ParsleyField instance for every multiple field. It will be stored in `data('ParsleyFieldMultiple')`\n    // And will be useful later to access classic `ParsleyField` stuff while being in a `ParsleyFieldMultiple` instance\n    this.bind('parsleyField', true);\n\n    return parsleyMultipleInstance || this.bind('parsleyFieldMultiple');\n  },\n\n  // Return proper `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`\n  bind: function (type, doNotStore) {\n    var parsleyInstance;\n\n    switch (type) {\n      case 'parsleyForm':\n        parsleyInstance = $.extend(\n          new ParsleyForm(this.$element, this.domOptions, this.options),\n          new ParsleyAbstract(),\n          window.ParsleyExtend\n        )._bindFields();\n        break;\n      case 'parsleyField':\n        parsleyInstance = $.extend(\n          new ParsleyField(this.$element, this.domOptions, this.options, this.parent),\n          new ParsleyAbstract(),\n          window.ParsleyExtend\n        );\n        break;\n      case 'parsleyFieldMultiple':\n        parsleyInstance = $.extend(\n          new ParsleyField(this.$element, this.domOptions, this.options, this.parent),\n          new ParsleyMultiple(),\n          new ParsleyAbstract(),\n          window.ParsleyExtend\n        )._init();\n        break;\n      default:\n        throw new Error(type + 'is not a supported Parsley type');\n    }\n\n    if (this.options.multiple)\n      ParsleyUtils.setAttr(this.$element, this.options.namespace, 'multiple', this.options.multiple);\n\n    if ('undefined' !== typeof doNotStore) {\n      this.$element.data('ParsleyFieldMultiple', parsleyInstance);\n\n      return parsleyInstance;\n    }\n\n    // Store the freshly bound instance in a DOM element for later access using jQuery `data()`\n    this.$element.data('Parsley', parsleyInstance);\n\n    // Tell the world we have a new ParsleyForm or ParsleyField instance!\n    parsleyInstance._actualizeTriggers();\n    parsleyInstance._trigger('init');\n\n    return parsleyInstance;\n  }\n};\n\nexport default ParsleyFactory;\n","import $ from 'jquery';\nimport ParsleyUtils from './utils';\nimport ParsleyDefaults from './defaults';\nimport ParsleyAbstract from './abstract';\nimport ParsleyValidatorRegistry from './validator_registry';\nimport ParsleyUI from './ui';\nimport ParsleyForm from './form';\nimport ParsleyField from './field';\nimport ParsleyMultiple from './multiple';\nimport ParsleyFactory from './factory';\n\nvar vernums = $.fn.jquery.split('.');\nif (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) {\n  throw \"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.\";\n}\nif (!vernums.forEach) {\n  ParsleyUtils.warn('Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim');\n}\n// Inherit `on`, `off` & `trigger` to Parsley:\nvar Parsley = $.extend(new ParsleyAbstract(), {\n    $element: $(document),\n    actualizeOptions: null,\n    _resetOptions: null,\n    Factory: ParsleyFactory,\n    version: '@@version'\n  });\n\n// Supplement ParsleyField and Form with ParsleyAbstract\n// This way, the constructors will have access to those methods\n$.extend(ParsleyField.prototype, ParsleyUI.Field, ParsleyAbstract.prototype);\n$.extend(ParsleyForm.prototype, ParsleyUI.Form, ParsleyAbstract.prototype);\n// Inherit actualizeOptions and _resetOptions:\n$.extend(ParsleyFactory.prototype, ParsleyAbstract.prototype);\n\n// ### jQuery API\n// `$('.elem').parsley(options)` or `$('.elem').psly(options)`\n$.fn.parsley = $.fn.psly = function (options) {\n  if (this.length > 1) {\n    var instances = [];\n\n    this.each(function () {\n      instances.push($(this).parsley(options));\n    });\n\n    return instances;\n  }\n\n  // Return undefined if applied to non existing DOM element\n  if (!$(this).length) {\n    ParsleyUtils.warn('You must bind Parsley on an existing element.');\n\n    return;\n  }\n\n  return new ParsleyFactory(this, options);\n};\n\n// ### ParsleyField and ParsleyForm extension\n// Ensure the extension is now defined if it wasn't previously\nif ('undefined' === typeof window.ParsleyExtend)\n  window.ParsleyExtend = {};\n\n// ### Parsley config\n// Inherit from ParsleyDefault, and copy over any existing values\nParsley.options = $.extend(ParsleyUtils.objectCreate(ParsleyDefaults), window.ParsleyConfig);\nwindow.ParsleyConfig = Parsley.options; // Old way of accessing global options\n\n// ### Globals\nwindow.Parsley = window.psly = Parsley;\nwindow.ParsleyUtils = ParsleyUtils;\n\n// ### Define methods that forward to the registry, and deprecate all access except through window.Parsley\nvar registry = window.Parsley._validatorRegistry = new ParsleyValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);\nwindow.ParsleyValidator = {};\n$.each('setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator'.split(' '), function (i, method) {\n  window.Parsley[method] = $.proxy(registry, method);\n  window.ParsleyValidator[method] = function () {\n    ParsleyUtils.warnOnce(`Accessing the method '${method}' through ParsleyValidator is deprecated. Simply call 'window.Parsley.${method}(...)'`);\n    return window.Parsley[method](...arguments);\n  };\n});\n\n// ### ParsleyUI\n// Deprecated global object\nwindow.Parsley.UI = ParsleyUI;\nwindow.ParsleyUI = {\n  removeError: function (instance, name, doNotUpdateClass) {\n    var updateClass = true !== doNotUpdateClass;\n    ParsleyUtils.warnOnce(`Accessing ParsleyUI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\n    return instance.removeError(name, {updateClass});\n  },\n  getErrorsMessages: function (instance) {\n    ParsleyUtils.warnOnce(`Accessing ParsleyUI is deprecated. Call 'getErrorsMessages' on the instance directly.`);\n    return instance.getErrorsMessages();\n  }\n};\n$.each('addError updateError'.split(' '), function (i, method) {\n  window.ParsleyUI[method] = function (instance, name, message, assert, doNotUpdateClass) {\n    var updateClass = true !== doNotUpdateClass;\n    ParsleyUtils.warnOnce(`Accessing ParsleyUI is deprecated. Call '${method}' on the instance directly. Please comment in issue 1073 as to your need to call this method.`);\n    return instance[method](name, {message, assert, updateClass});\n  };\n});\n\n// ### PARSLEY auto-binding\n// Prevent it by setting `ParsleyConfig.autoBind` to `false`\nif (false !== window.ParsleyConfig.autoBind) {\n  $(function () {\n    // Works only on `data-parsley-validate`.\n    if ($('[data-parsley-validate]').length)\n      $('[data-parsley-validate]').parsley();\n  });\n}\n\nexport default Parsley;\n","import $ from 'jquery';\n\nimport Parsley from './main';\n\n$.extend(true, Parsley, {\n  asyncValidators: {\n    'default': {\n      fn: function (xhr) {\n        // By default, only status 2xx are deemed successful.\n        // Note: we use status instead of state() because responses with status 200\n        // but invalid messages (e.g. an empty body for content type set to JSON) will\n        // result in state() === 'rejected'.\n        return xhr.status >= 200 && xhr.status < 300;\n      },\n      url: false\n    },\n    reverse: {\n      fn: function (xhr) {\n        // If reverse option is set, a failing ajax request is considered successful\n        return xhr.status < 200 || xhr.status >= 300;\n      },\n      url: false\n    }\n  },\n\n  addAsyncValidator: function (name, fn, url, options) {\n    Parsley.asyncValidators[name] = {\n      fn: fn,\n      url: url || false,\n      options: options || {}\n    };\n\n    return this;\n  }\n\n});\n\nParsley.addValidator('remote', {\n  requirementType: {\n    '': 'string',\n    'validator': 'string',\n    'reverse': 'boolean',\n    'options': 'object'\n  },\n\n  validateString: function (value, url, options, instance) {\n    var data = {};\n    var ajaxOptions;\n    var csr;\n    var validator = options.validator || (true === options.reverse ? 'reverse' : 'default');\n\n    if ('undefined' === typeof Parsley.asyncValidators[validator])\n      throw new Error('Calling an undefined async validator: `' + validator + '`');\n\n    url = Parsley.asyncValidators[validator].url || url;\n\n    // Fill current value\n    if (url.indexOf('{value}') > -1) {\n      url = url.replace('{value}', encodeURIComponent(value));\n    } else {\n      data[instance.$element.attr('name') || instance.$element.attr('id')] = value;\n    }\n\n    // Merge options passed in from the function with the ones in the attribute\n    var remoteOptions = $.extend(true, options.options || {} , Parsley.asyncValidators[validator].options);\n\n    // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`\n    ajaxOptions = $.extend(true, {}, {\n      url: url,\n      data: data,\n      type: 'GET'\n    }, remoteOptions);\n\n    // Generate store key based on ajax options\n    instance.trigger('field:ajaxoptions', instance, ajaxOptions);\n\n    csr = $.param(ajaxOptions);\n\n    // Initialise querry cache\n    if ('undefined' === typeof Parsley._remoteCache)\n      Parsley._remoteCache = {};\n\n    // Try to retrieve stored xhr\n    var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);\n\n    var handleXhr = function () {\n      var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);\n      if (!result) // Map falsy results to rejected promise\n        result = $.Deferred().reject();\n      return $.when(result);\n    };\n\n    return xhr.then(handleXhr, handleXhr);\n  },\n\n  priority: -1\n});\n\nParsley.on('form:submit', function () {\n  Parsley._remoteCache = {};\n});\n\nwindow.ParsleyExtend.addAsyncValidator = function () {\n  ParsleyUtils.warnOnce('Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`');\n  return Parsley.addAsyncValidator(...arguments);\n};\n","// This is included with the Parsley library itself,\n// thus there is no use in adding it to your project.\nimport Parsley from '../parsley/main';\n\nParsley.addMessages('en', {\n  defaultMessage: \"This value seems to be invalid.\",\n  type: {\n    email:        \"This value should be a valid email.\",\n    url:          \"This value should be a valid url.\",\n    number:       \"This value should be a valid number.\",\n    integer:      \"This value should be a valid integer.\",\n    digits:       \"This value should be digits.\",\n    alphanum:     \"This value should be alphanumeric.\"\n  },\n  notblank:       \"This value should not be blank.\",\n  required:       \"This value is required.\",\n  pattern:        \"This value seems to be invalid.\",\n  min:            \"This value should be greater than or equal to %s.\",\n  max:            \"This value should be lower than or equal to %s.\",\n  range:          \"This value should be between %s and %s.\",\n  minlength:      \"This value is too short. It should have %s characters or more.\",\n  maxlength:      \"This value is too long. It should have %s characters or fewer.\",\n  length:         \"This value length is invalid. It should be between %s and %s characters long.\",\n  mincheck:       \"You must select at least %s choices.\",\n  maxcheck:       \"You must select %s choices or fewer.\",\n  check:          \"You must select between %s and %s choices.\",\n  equalto:        \"This value should be the same.\"\n});\n\nParsley.setLocale('en');\n","import $ from 'jquery';\nimport Parsley from './parsley/main';\nimport './parsley/pubsub';\nimport './parsley/remote';\nimport './i18n/en';\nimport inputevent from './vendor/inputevent';\n\ninputevent.install();\n\nexport default Parsley;\n"],"sourceRoot":"/source/"}